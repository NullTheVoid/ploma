<html>
<head>
<style>
body {
  font-family: sans-serif;
}
canvas {
  float: left;
  cursor: url('cursors/cursor.cur'), crosshair;
  border: 1px solid gray;
}
img {
  display: none;
}
a {
  padding: 10px;
  line-height: 40px;
  cursor: pointer;
  color: white;
  text-decoration: none;
  -moz-user-select: none;
}
/*http://www.colourlovers.com/palette/3412827/21st*/
#contrast {
  background: #BCBDAC;
}
#sharpness {
  background: #CFBE27;
}
#undo {
  background: #F27435;
}
#save {
  background: #3B2D38;
}
#clear {
  background: #F02475;
}
</style>
</head>

<body>
<canvas id="canvas"></canvas>
<div id="buttons">
  <a id="contrast">Contrast</a>
  <br>
  <a id="sharpness">Sharpness</a>
  <br>
  <br>
  <br>
  <a id="undo">Undo</a>
  <br>
  <a id="save">Save</a>
  <br>
  <br>
  <br>
  <a id="clear">Clear</a>
</div>
<img src="img/image0052-1-b5-4_sm-2.png" id="img"/>
<object id="wtPlugin" type="application/x-wacomtabletplugin">
  <param name="onload" value="pluginLoaded" />
</object>
</body>

<script src='js/ploma_module.js'></script>
<script>
var w = 1300;
var h = 1000;
var ratio = 2;
var cursorOffsetX = 8;
var cursorOffsetY = 8;
var sample = 2;
var isDrawing = false;
var emptyInk = 1;
var skipCounter = 0;
var penDownFrame = 0;
var mouseMoveCounter = 0;
var points = [];
var canvas;
var button;
var button2;
var img;
var plugin;
var ctx;
var pat;
var storedImageData;
var penDownTime = 0;
var curX;
var curY;
var lasX;
var lasY;
var latencies = [];

window.onload = function() {
  canvas = document.getElementById('canvas');
  contrast = document.getElementById('contrast');
  sharpness = document.getElementById('sharpness');
  save = document.getElementById('save');
  undo = document.getElementById('undo');
  clear = document.getElementById('clear');
  img = document.getElementById("img");
  plugin = document.getElementById('wtPlugin');
  canvas.setAttribute('width', w * ratio);
  canvas.setAttribute('height', h * ratio);
  canvas.style.width = w;
  canvas.style.height = h;
  ctx = canvas.getContext('2d');
  pat = ctx.createPattern(img,"repeat");
  ctx.scale(ratio, ratio);
  ctx.strokeStyle = pat;
  clearCanvas();

  save.onclick = function(e) {
    window.open(canvas.toDataURL());
  }

  undo.onclick = function(e) {
    ctx.putImageData(storedImageData, 0, 0, 0, 0, w*ratio, h*ratio);
  }

  sharpness.onclick = function(e) {
    var newImageData;
    var weights;
    weights = [0, -1,  0, -1,  5, -1, 0, -1,  0];
    storedImageData = ctx.getImageData(0, 0, w*ratio, h*ratio);
    newImageData = convolute(storedImageData, weights);
    ctx.putImageData(newImageData, 0, 0, 0, 0, w*ratio, h*ratio);
  }

  contrast.onclick = function(e) {
    var newImageData;
    var factor = 40;
    storedImageData = ctx.getImageData(0, 0, w*ratio, h*ratio);
    newImageData = contrastImage(storedImageData, factor);
    ctx.putImageData(newImageData, 0, 0, 0, 0, w*ratio, h*ratio);
  }

  clear.onclick = function(e) {
    clearCanvas();
  }

  canvas.onmousedown = function(e) {
    isDrawing = true;
    penDownFrame = 0;
    recordPoint(e);
    penDownTime = Date.now();
    points = [];
    latencies = [];
  };

  canvas.onmousemove = function(e) {
    if (!isDrawing) {
      return;
    }

    penDownFrame++;
    mouseMoveCounter++;
    if (mouseMoveCounter % 1 === 0){
      recordPoint(e);
    }
  };

  canvas.onmouseup = function(e) {
    isDrawing = false;
    recordPoint(e);
    redraw();
    points = [];
    // calculate average latency
    //var sum = 0;
    //for ( var i = 0 ; i < latencies.length; i++) {
    //  sum+= latencies[i];
    //}
    //console.log('average latency: ' + sum/latencies.length);
  };

  // init
  redraw();
  
}

// requestAnimFrame shim layer by Paul Irish
var requestAnimFrame = (function(){
  return window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(callback, element){
      window.setTimeout(callback, 1000 / 60);
    };
})();

function redraw(time) {
  requestAnimFrame(redraw);

  if (!isDrawing) {
    return;
  }

  if((Date.now() - penDownTime) > 40 && (points.length > 10)) {
    var sampledCurve = getSampledPoints(points);
    sampledCurve.push(sampledCurve[sampledCurve.length-1]);
    drawCurve(sampledCurve);
    points = [];
    // start the new curve where this one leaves off
    points.push(sampledCurve[sampledCurve.length-1]);
    penDownTime = Date.now();
  }

};

function drawCurve(pts) {
  var p1 = pts[0];
  var p2 = pts[1];
  var from = p1;
  for (var i = 1; i < pts.length; i++) {
    if(p1) {
      var midPoint = getMidPt(p1, p2);
      var to = midPoint;
      var ctrl = p1;
      var a = [];
      for (var t = 0; t <= 1; t += 0.5) {
        var newPoint = [];
        newPoint[0] =
          (1 - t) * (1 - t) * from[0] +
          2 * (1 - t) * t * ctrl[0] +
          t * t * to[0];
        newPoint[1] =
          (1 - t) * (1 - t) * from[1] +
          2 * (1 - t) * t * ctrl[1] +
          t * t * to[1];
        newPoint[2] = (from[2] + to[2] + ctrl[2]) / 3;
        newPoint[3] = from[3] + ((to[3] - from[3]) /2);
        newPoint[4] = from[4];
        newPoint[5] = from[5];
        a.push(newPoint);
      }
      drawSegments(a);
    }
    p1 = pts[i];
    p2 = pts[i+1];
    from = midPoint;
  }
}

function drawSegments(pts) {
  var px;
  var py;
  var minpt;
  var minx;
  var miny;

  for(var i = 0; i < pts.length-1; i++) {
    px = pts[i][0];
    py = pts[i][1];
    x = pts[i+1][0];
    y = pts[i+1][1];
    latencies.push(Date.now() - pts[i][3]);

    minpt = getMinPt([px, py], pts[i+1]);
    minx = minpt[0];
    miny = minpt[1];

    ctx.lineWidth = Module.calcLineWidth(pts[i+1][2]);
    ctx.globalAlpha = Module.calcGlobalAlpha(
      pts[i+1][2],
      pts[i+1][4],
      pts[i+1][5])
    ;

    ctx.translate(minx, miny);
    ctx.beginPath();
    ctx.moveTo(px - minx, py - miny);
    ctx.lineTo(x - minx, y - miny);
    ctx.stroke();
    ctx.closePath();
    ctx.translate(-minx, -miny);
  }
}

function recordPoint(e) {
  var x = e.clientX - cursorOffsetX;
  var y = e.clientY - cursorOffsetY; 
  /*if (emptyInk) {
    skipCounter++;
    if (skipCounter > 8) {
      emptyInk = 0;
    }
  } else {
    if (penDownFrame < 12 && ((Math.floor(Math.random()*20)) === 3)) {
      emptyInk = 1;
      skipCounter = 0;
    }
  }*/
  emptyInk = 1;
  skipCounter = 0;
  point = [
    x,                      // x: 0
    y,                      // y: 1
    //plugin.penAPI.pressure, // p: 2
    1,
    Date.now(),             // t: 3
    emptyInk,               // e: 4
    skipCounter             // s: 5
  ];
  /*if(point[2] < 0.6) {
    if (Math.floor(Math.random()*100) === 3) {
      point[2] = 0.5;
    }
  }*/
  points.push(point);
}

function getSampledPoints(pts) {
  var newPoints = [];
  for(var i = 0; i < pts.length; i++) {
    if (i%sample === 0) {
      newPoints.push(pts[i]);
    }
    if (i === pts.length-1) {
      newPoints.push(pts[i]);
    }
  }
  return newPoints;
}

function getMinPt(p1, p2) {
  return [
    Math.min(p1[0], p2[0]) + Math.random()*50,
    Math.min(p1[1], p2[1]) + Math.random()*50
  ];
}

function getMidPt(p1, p2) {
  return [
    p1[0] + (p2[0] - p1[0]) / 2,    // x: 0
    p1[1] + (p2[1] - p1[1]) / 2,    // y: 1
    (p1[2] + p2[2]) / 2,            // p: 2
    p1[3] + ((p2[3] - p1[3]) / 2),  // t: 3
    p1[4],                          // e: 4
    p1[5]                           // s: 5
  ];
}

function getCurveArea(pts) {
  var minX = pts[0][0];
  var minY = pts[0][1];
  var maxX = pts[0][0];
  var maxY = pts[0][1];
  var area;
  for(var i = 0; i < pts.length; i++) {
    minX = Math.min(minX, pts[i][0]);
    minY = Math.min(minY, pts[i][1]);
    maxX = Math.max(maxX, pts[i][0]);
    maxY = Math.max(maxY, pts[i][1]);
  }
  area = (maxX - minX)*(maxY - minY);
  return area;
}

function contrastImage(imageData, contrast) {
  var data = imageData.data;
  var factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
  for(var i=0;i<data.length;i+=4) {
    data[i] = factor * (data[i] - 128) + 128;
    data[i+1] = factor * (data[i+1] - 128) + 128;
    data[i+2] = factor * (data[i+2] - 128) + 128;
    // reduce the saturation?
  }
  return imageData;
}

function convolute(pixels, weights, opaque) {
  var side = Math.round(Math.sqrt(weights.length));
  var halfSide = Math.floor(side/2);
  var src = pixels.data;
  var sw = pixels.width;
  var sh = pixels.height;
  // pad output by the convolution matrix
  var w = sw;
  var h = sh;
  var tmpCanvas = document.createElement('canvas');
  var tmpCtx = tmpCanvas.getContext('2d');
  var output = tmpCtx.createImageData(w, h);
  var dst = output.data;
  // go through the destination image pixels
  var alphaFac = opaque ? 1 : 0;
  for (var y=0; y<h; y++) {
    for (var x=0; x<w; x++) {
      var sy = y;
      var sx = x;
      var dstOff = (y*w+x)*4;
      // calculate the weighed sum of the source image pixels that
      // fall under the convolution matrix
      var r=0, g=0, b=0, a=0;
      for (var cy=0; cy<side; cy++) {
        for (var cx=0; cx<side; cx++) {
          var scy = sy + cy - halfSide;
          var scx = sx + cx - halfSide;
          if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
            var srcOff = (scy*sw+scx)*4;
            var wt = weights[cy*side+cx];
            r += src[srcOff] * wt;
            g += src[srcOff+1] * wt;
            b += src[srcOff+2] * wt;
            a += src[srcOff+3] * wt;
          }
        }
      }
      dst[dstOff] = r;
      dst[dstOff+1] = g;
      dst[dstOff+2] = b;
      dst[dstOff+3] = a + alphaFac*(255-a);
    }
  }
  return output;
};

function clearCanvas(){
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = 'rgb(253, 254, 251)';
  ctx.globalAlpha = 1;
  ctx.fillRect(0, 0, w, h);
}

</script>

</html>