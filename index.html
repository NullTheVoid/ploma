<html>
  <head>
    <style>
      canvas {
        cursor: url('cursors/cursor.cur'), crosshair;
        border: 1px solid yellow;
      }
      img {
        display: none;
      }
      a {
        cursor: pointer;
        border-radius: 10px;
        padding: 10px 5px;
        color: white;
        text-decoration: none;
        font-family: sans-serif;
        user-select: none;
      }
      #capture {
        background: blue;
      }
      #clear {
        margin-top: 10px;
        background: #DD3333;
      }
    </style>
  </head>

  <body>
    <canvas id="c"></canvas>
    <div id="buttons" style="float: right;">
      <a id='capture' style="float: left;">Capture</a><br>
      <a id='clear' style="float: left;">Clear</a>
    </div>
    <img src="img/image0052-1-b5-4_sm-2.png" id="img"/>
    <object id="wtPlugin" type="application/x-wacomtabletplugin">
      <param name="onload" value="pluginLoaded" />
    </object>
  </body>

  <script src='js/hybrid-drawing-realtime.js'></script>
  <script>
    var button;
    var button2;
    var el;
    var w = 1300;
    var h = 1000;
    var ratio = 2;
    var img;
    var plugin;
    var ctx;
    var pat;
    var pat3;
    var cursorOffsetX = 12;
    var cursorOffsetY = 8;
    var isDrawing = false;
    var isSkipping = false;
    var skipCounter = 0;
    var penDownFrame = 0;
    var emptyInk = true;
    var x;
    var y;
    var px;
    var py;
    var points = [];
    var drawTimeout;
    var sample = 1;
    var mouseMoveCounter = 0;

    var doDrawing = function() {
      
    }

    function getMinPt(x1, y1, x2, y2, x3, y3, x4, y4) {
      var minx = Math.min(x1, x2, x3, x4) + Math.random()*50;
      var miny = Math.min(y1, y2, y3, y4) + Math.random()*50;

      return {x: minx, y: miny};
    }

    function getCurveArea(c) {
      var minX = c[0].canvasX;
      var minY = c[0].canvasY;
      var maxX = c[0].canvasX;
      var maxY = c[0].canvasY;
      var area;

      for(var i = 0; i < c.length; i++) {
        minX = Math.min(minX, c[i].canvasX);
        minY = Math.min(minY, c[i].canvasY);
        maxX = Math.max(maxX, c[i].canvasX);
        maxY = Math.max(maxY, c[i].canvasY);
      }

      area = (maxX - minX)*(maxY - minY);

      return area;
    }

    function getSampledCurve(c, s) {
      var sampledCurve = [];
      for (var i = 0; i < c.length; i++) {
        if(i%s === 0) {
          sampledCurve.push(c[i]);
        }
        // always keep the last point
        if(i === c.length-1) {
          sampledCurve.push(c[i]);
        }
      }
      return sampledCurve;
    }

    function pressureMapValue10(v){
      return Math.round(Math.round(v*100)/10)*10;
    }

    function pressureMapValue(v){
      return Math.round(Math.round(v*100)/5)*5;
    }

    //**********************************************************************
    // window.onload
    //
    window.onload = function() {
      button = document.getElementById('capture');
      button2 = document.getElementById('clear');
      el = document.getElementById('c');
      img = document.getElementById("img");
      plugin = document.getElementById('wtPlugin');
      ctx = el.getContext('2d');
      pat = ctx.createPattern(img,"repeat");
      pat3 = pat;
      el.setAttribute('width', w * ratio);
      el.setAttribute('height', h * ratio);
      el.style.width = w;
      el.style.height = h;
      ctx.scale(ratio, ratio);

      // set global rendering properties
      ctx.strokeStyle = pat;
      clearCanvas();

      // *********************************************************************
      // button.onclick
      //   Saves the points to JSON and gives an output file to download and
      //   then clears the canvas.
      //
      button.onclick = function(e) {
        var json = JSON.stringify(points);
        var blob = new Blob([json], {type: 'application/json'});
        var url  = URL.createObjectURL(blob);
        button.download = 'capture_'+Date.now()+'.json';
        button.href = url;
        points.length = 0;
      }

      button2.onclick = function(e) {
        clearCanvas();
      }

      el.onmousedown = function(e) {
        isDrawing = true;

        x = e.clientX - cursorOffsetX;
        y = e.clientY - cursorOffsetY;
        px = x;
        py = y;

        point = {
          isWacom      : plugin.penAPI.isWacom,
          isEraser     : plugin.penAPI.isEraser,
          posX         : plugin.penAPI.posX,
          posY         : plugin.penAPI.posY,
          sysX         : plugin.penAPI.sysX,
          sysY         : plugin.penAPI.sysY,
          tabX         : plugin.penAPI.tabX,
          tabY         : plugin.penAPI.tabY,
          rotationDeg  : plugin.penAPI.rotationDeg,
          rotationRad  : plugin.penAPI.rotationRad,
          tiltX        : plugin.penAPI.tiltX,
          tiltY        : plugin.penAPI.tiltY,
          tangPressure : plugin.penAPI.tangentialPressure,
          version      : plugin.penAPI.version,
          pointerType  : plugin.penAPI.pointerType,
          tabletModel  : plugin.penAPI.tabletModel,
          pressure     : plugin.penAPI.pressure,
          canvasX      : x,
          canvasY      : y,
          time         : Date.now()
        };
        points.push(point);

        penDownFrame = 0;
      };

      el.onmousemove = function(e) {
        var minx;
        var miny;
        var pressure;
        var point;
        mouseMoveCounter++;
        penDownFrame++;

        if (!(mouseMoveCounter % 2 === 0)){
          return;
        }

        if (!isDrawing) {
          return;
        }

        if (points.length > 10) {
          capture = points;
          points = [];
          points.push(capture[capture.length-1]);
          redrawHybridDrawing();
        }

        x = e.clientX - cursorOffsetX;
        y = e.clientY - cursorOffsetY;
        minx = Math.min(x, px) + Math.random()*50;
        miny = Math.min(y, py) + Math.random()*50;

        point = {
          isWacom      : plugin.penAPI.isWacom,
          isEraser     : plugin.penAPI.isEraser,
          posX         : plugin.penAPI.posX,
          posY         : plugin.penAPI.posY,
          sysX         : plugin.penAPI.sysX,
          sysY         : plugin.penAPI.sysY,
          tabX         : plugin.penAPI.tabX,
          tabY         : plugin.penAPI.tabY,
          rotationDeg  : plugin.penAPI.rotationDeg,
          rotationRad  : plugin.penAPI.rotationRad,
          tiltX        : plugin.penAPI.tiltX,
          tiltY        : plugin.penAPI.tiltY,
          tangPressure : plugin.penAPI.tangentialPressure,
          version      : plugin.penAPI.version,
          pointerType  : plugin.penAPI.pointerType,
          tabletModel  : plugin.penAPI.tabletModel,
          pressure     : plugin.penAPI.pressure,
          canvasX      : x,
          canvasY      : y,
          time         : Date.now()
        };
        points.push(point);

        px = x;
        py = y;
      };

      el.onmouseup = function() {
        isDrawing = false;
        capture = points;
        points = [];
        //points.push(capture[capture.length-1]);
        redrawHybridDrawing();
      };
      
    }

    function calcLineWidthDrawing(p) {
      var width;

      if(p < 0.4) {
        width = ((p)/(0.4))*(0.7);
      }

      if((p >= 0.4) && (p < 0.7)) {
        width = ((p-0.4)/(0.3))*(2);
      }

      if((p >= 0.7) && (p < 0.9)) {
        width = 2.5;
      }

      if((p >= 0.9)) {
        width = 2.8;
      }

      return width;
    }

    function calcGlobalAlphaDrawing(p) {
      var alpha;

      if(isSkipping && (skipCounter > 30)) {
        isSkipping = false;
        skipCounter = 0;
      }

      if(emptyInk) {
        isSkipping = true;
        emptyInk = false;
        window.setTimeout(function() {
          emptyInk = true;
        }, 2000);
      }

      if(isSkipping) {
        alpha = 0.3+(skipCounter/100);
        skipCounter++;
      } else {
        if(p < 0.4) {
          alpha = 0.3;
        } else {
          alpha = 0.9;
        }
      }
      
      return alpha;
    }

    function calcStrokeStyleDrawing(p) {
      style = pat3;

      return style;
    }

    //**********************************************************************
    // window.onkeypress
    //   'i' to save out image
    //   'c' to clear canvas
    //   'j' saves points to json blob
    //
    window.onkeypress = function(e) {
      /*if (e.charCode === 99) {
        clearCanvas();
        curves.length = 0;
      }*/
      if (e.charCode === 105) {
        window.open(el.toDataURL());
      }
      if (e.charCode === 106) {
        var json = JSON.stringify(points);
        var blob = new Blob([json], {type: 'application/json'});
        var url  = URL.createObjectURL(blob);
        window.open(url);
      }
    }

    //**********************************************************************
    // clearCanvas
    //
    //
    function clearCanvas(){
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.fillStyle = 'rgb(253, 254, 251)';
      ctx.globalAlpha = 1;
      ctx.fillRect(0, 0, 1300, 950);
    }
  </script>

</html>