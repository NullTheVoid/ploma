<!--
Ploma - High-fidelity ballpoint pen rendering
v0.1
Optimized for Wacom Cintiq 13HD

Evelyn Eastmond
Dan Amelang
Communications Design Group
SAP
(c) 2014

TODO: License
-->

<html>
<head>
<style>
  body {
    font-family: sans-serif;
  }
  canvas#canvas {
    float: left;
    cursor: none;
    border: 1px solid gray;
  }
  img {
    display: none;
  }
  a {
    padding: 10px;
    line-height: 40px;
    cursor: pointer;
    color: white;
    text-decoration: none;
  }
  .noselect {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
  #save {
    background: #3B2D38;
  }
  #clear {
    background: #F02475;
  }
</style>
</head>

<body>
<canvas id="canvas"></canvas>
<canvas id="texture-canvas"></canvas>
<div id="buttons">
  <a id="save" class="noselect">Save</a>
  <br>
  <br>
  <a id="clear" class="noselect">Clear</a>
  <br>
  <br>
  <br>
  <input type="checkbox" id="cursor" class="noselect"/> Show Cursor
  <br>
  <input type="checkbox" id="mouse" class="noselect"/> Use Mouse
</div>
<img src="img/rubbing_to_mask 3.jpeg" id="texture1"/>
<img src="img/rubbing_to_mask 1.jpeg" id="texture2"/>
<object id="wtPlugin" type="application/x-wacomtabletplugin">
  <param name="onload" value="pluginLoaded"/>
</object>
</body>

<script>
// State
var w = 1300;
var h = 1000;
var cursorOffsetX = 8;
var cursorOffsetY = 6;
var inputStrokes = [];
var filteredStrokes = [];
var curInputStroke = null;
var curFilteredStroke = null;
var isDrawing = false;
var minx = null;
var maxx = null;
var miny = null;
var maxy = null;
var lastControlPoint = null;
var stepOffset = 0;
var stepInterval = 0.30;
var filterWeight = 50;
var textureOffsetX = 0;
var textureOffsetY = 0;
var mouseMoveCounter = 0;
var useMouse = false;

// DOM
var canvas;
var textureCanvas;
var imageData;
var save;
var clear;
var cursor;
var texture1;
var texture2;
var textureImageData1;
var textureImageData2;
var plugin;
var ctx;
var paperColor = 'rgb(255, 255, 255)';

window.onload = function() {
  initDOMElements();
  initEvents();
  clearCanvas();
}

function initDOMElements() {
  canvas = document.getElementById('canvas');
  canvas.setAttribute('width', w);
  canvas.setAttribute('height', h);
  save = document.getElementById('save');
  clear = document.getElementById('clear');
  cursor = document.getElementById('cursor');
  texture1 = document.getElementById("texture1");
  texture2 = document.getElementById("texture2");
  textureCanvas = document.getElementById("texture-canvas");
  plugin = document.getElementById('wtPlugin');

  // prepare textures
  textureCanvas.width = texture1.width + texture2.width;
  textureCanvas.height = texture1.height;
  textureCanvas.getContext('2d').drawImage(texture1, 0, 0, texture1.width, texture1.height);
  textureCanvas.getContext('2d').drawImage(texture2, texture1.width, 0, texture2.width, texture2.height);
  textureImageData1 = textureCanvas.getContext('2d').getImageData(0, 0, texture1.width, texture1.height).data;
  textureImageData2 = textureCanvas.getContext('2d').getImageData(texture1.width, 0, texture2.width, texture2.height).data;
  //console.log('textureImageData1: ' + textureImageData1);
  //console.log('width = ' + texture1.width);
  //console.log('height = ' + texture1.height);

  // prepare canvas context
  ctx = canvas.getContext('2d');

  // If pen is not detected at startup
  // assume that we're using a mouse
  //
  // TODO: check for plugin loading time, it is
  // not as synchronous as it seems
  //if (!plugin.penAPI || !plugin.penAPI.pressure) {
  //  useMouse = true;
  //  mouse.checked = true;
  //}
}

function initEvents() {
  save.onclick = function(e) {
    window.open(canvas.toDataURL());
  }
  clear.onclick = function(e) {
    clearCanvas();
  }
  cursor.onclick = function(e) {
    if(cursor.checked) {
      canvas.style.cursor = 'crosshair';
    } else {
      canvas.style.cursor = 'none';
    }
  }
  mouse.onclick = function(e) {
    useMouse = mouse.checked;
  }
  canvas.onmousedown = function(e) {
    var point = getEventPoint(e);
    isDrawing = true;
    stepOffset = stepInterval;

    curInputStroke = [point];
    inputStrokes.push(curInputStroke);

    curFilteredStroke = [point];
    filteredStrokes.push(curFilteredStroke);
  }
  canvas.onmousemove = function(e) {
    mouseMoveCounter++;
    if (!isDrawing) return;
    
    var point = getEventPoint(e);

    // ignore duplicates in the same stroke
    if(curInputStroke.last().equals(point) || (mouseMoveCounter % 2 === 0)) {
      return;
    }

    // push current point
    curInputStroke.push(point);

    // filter inputs
    var len = curInputStroke.length;
    var fpoint = calculateFilteredPoint(
      curInputStroke[len - 3],
      curInputStroke[len - 2],
      curInputStroke[len - 1]
    );
    if(fpoint) {
      curFilteredStroke.push(fpoint);
    }

    redraw();
  }
  canvas.onmouseup = function(e) {
    var point = getEventPoint(e);
    // keep the last point as is for now
    // TODO: Try to address the "tapering on mouseup" issue
    curInputStroke.push(point);
    curFilteredStroke.push(point);
    redraw();
    isDrawing = false;
    lastControlPoint = null;
  }
}

function redraw() {
  if (!isDrawing) {
    return;
  }
  // TODO: Handle single point and double point strokes
  // 3 points needed for a look-ahead bezier
  if(curFilteredStroke.length >= 3) {
    var len = curFilteredStroke.length;
    createAndDrawBezier([
      curFilteredStroke[len - 3],
      curFilteredStroke[len - 2],
      curFilteredStroke[len - 1]
    ]);
  }
};

// draw a look-ahead cubic bezier based on 3 points
function createAndDrawBezier(pts) {
  minx = w;
  miny = h;
  maxx = 0;
  maxy = 0;

  // endpoints and control points
  var p0 = pts[0];
  var p3 = pts[1];
  var p1;
  var p2;

  // calculate p1
  if(!lastControlPoint) {
    p1 = new Point(
      p0.x + (p3.x - p0.x) * 0.33,
      p0.y + (p3.y - p0.y) * 0.33,
      p0.p + (p3.p - p0.p) * 0.33
    );
  } else {
    p1 = lastControlPoint.getMirroredPt(p0);
  }

  // calculate p2
  if (pts[2]) {
    p2 = new Point(
      p3.x - (((p3.x - p0.x) + (pts[2].x - p3.x)) / 2 / 3),
      p3.y - (((p3.y - p0.y) + (pts[2].y - p3.y)) / 2 / 3),
      p3.p - (((p3.p - p0.p) + (pts[2].p - p3.p)) / 2 / 3)
    );
  } else {
    p2 = new Point(
      p0.x + (p3.x - p0.x) * 0.66,
      p0.y + (p3.y - p0.y) * 0.66,
      p0.p + (p3.p - p0.p) * 0.66
    );
  }

  // set last control point
  lastControlPoint = p2;

  // step along curve
  var stepPoints = calculateStepPoints(p0, p1, p2, p3);
  for(var i = 0; i < stepPoints.length; i++) {
    drawStep(imageData, stepPoints[i]);
  }

  // set image using a crude dirty rect
  ctx.putImageData(imageData, 0, 0, minx, miny, maxx - minx + 10, maxy - miny + 10);
}

// calculate even steps along a bezier (p0, p1, p2, p3)
function calculateStepPoints(p0, p1, p2, p3) {
  var stepPoints = [];
  var i = stepInterval;

  // algebraic conveniences
  // not geometric
  var A_x = p3.x - 3 * p2.x + 3 * p1.x - p0.x;
  var A_y = p3.y - 3 * p2.y + 3 * p1.y - p0.y;
  var A_p = p3.p - 3 * p2.p + 3 * p1.p - p0.p;
  var B_x = 3 * p2.x - 6 * p1.x + 3 * p0.x;
  var B_y = 3 * p2.y - 6 * p1.y + 3 * p0.y;
  var B_p = 3 * p2.p - 6 * p1.p + 3 * p0.p;
  var C_x = 3 * p1.x - 3 * p0.x;
  var C_y = 3 * p1.y - 3 * p0.y;
  var C_p = 3 * p1.p - 3 * p0.p;

  var t = (i - stepOffset) / Math.sqrt(C_x * C_x + C_y * C_y);

  while (t <= 1.0) {
    // point
    var step_x = t * (t * (t * A_x + B_x) + C_x) + p0.x;
    var step_y = t * (t * (t * A_y + B_y) + C_y) + p0.y;
    var step_p = t * (t * (t * A_p + B_p) + C_p) + p0.p;
    stepPoints.push(new Point(
      step_x,
      step_y,
      step_p
    ));

    // step distance til next one
    var s_x = t * (t * 3 * A_x + 2 * B_x) + C_x; // dx/dt
    var s_y = t * (t * 3 * A_y + 2 * B_y) + C_y; // dy/dt
    var s = Math.sqrt(s_x * s_x + s_y * s_y); // s = derivative in 2D space
    var dt = i / s; // i = interval / derivative in 2D
    t = t + dt;
  }

  // TODO: maybe later use a better approximation for distance along the bezier?
  if (stepPoints.length == 0) // We didn't step at all along this Bezier
    stepOffset = stepOffset + p0.getDistance(p3);
  else
    stepOffset = stepPoints.last().getDistance(p3);

  return stepPoints;
}

function calculateFilteredPoint(p1, p2, p3) {
  var w = filterWeight / 100;
  if (p1 == null || p2 == null || p3 == null)
    return null; // Not enough points yet to filter
  var m = p1.getMidPt(p3);
  return new Point(
    w * p2.x + (1 - w) * m.x,
    w * p2.y + (1 - w) * m.y,
    w * p2.p + (1 - w) * m.p
  );
}

// calculate non-linear width offset (range [-2, 1]) based on pressure
function calculateWidth(p) {
  var width;
  
  /*if(p < 0) { // from bezier
    width = -2;
  }
  if(p < 0.4) {
    width = map(p, 0, 0.4, -2, 0.2);
  } 
  if((p >= 0.4) && (p < 0.45)) {
    width = map(p, 0.4, 0.45, 0.2, 0.25);
  }
  if((p >= 0.45) && (p < 0.8)) {
    width = map(p, 0.45, 0.8, 0.25, 0.50);
  }
  if((p >= 0.8) && (p < 0.95)) {
    width = map(p, 0.8, 0.95, 0.5, 0.6);
  }
  if((p >= 0.95) && (p <=0.99)) {
    width = map(p, 0.95, 0.99, 0.6, 0.65);
  }
  if((p >= 0.99) && (p <=1)) {
    //width = map(p, 0.99, 1, 0.65, 0.85);
    width = map(p, 0.99, 1, 0.65, 0.85)
  }
  if(p > 1) { // from bezier
    width = 1;
  }*/

  if(p < 0) { // from bezier
    width = -2;
  }
  if(p < 0.4) {
    width = map(p, 0, 0.4, -2, 0.2);
  } 
  if((p >= 0.4) && (p < 0.45)) {
    width = map(p, 0.4, 0.45, 0.2, 0.25);
  }
  if((p >= 0.45) && (p < 0.8)) {
    width = map(p, 0.45, 0.8, 0.25, 0.50);
  }
  if((p >= 0.8) && (p < 0.95)) {
    width = map(p, 0.8, 0.95, 0.5, 0.7);
  }
  if((p >= 0.95) && (p <=0.99)) {
    width = map(p, 0.95, 0.99, 0.7, 0.95);
  }
  if((p >= 0.99) && (p <=1)) {
    //width = map(p, 0.99, 1, 0.65, 0.85);
    width = map(p, 0.99, 1, 0.95, 1.05)
  }
  if(p > 1) { // from bezier
    width = 1.2;
  }

  return width;
}

// draw a pixel grid at a step point
function drawStep(id, point) {
  var width = calculateWidth(point.p);

  for(var i = Math.round(point.x) - 2; i < Math.round(point.x) + 3; i++) {
    for(var j = Math.round(point.y) - 2; j < Math.round(point.y) + 3; j++) {

      // update bounding rect
      minx = Math.min(minx, i);
      maxx = Math.max(maxx, i);
      miny = Math.min(miny, j);
      maxy = Math.max(maxy, j);

      // distance
      var dist = point.getDistance(new Point(i, j));

      // antialiasing
      var a = 0.1/(dist - width) - 0.06;

      // spike
      if(dist < width) {
        a = 1;
      }
      
      // clamp alpha
      if (a < 0) a = 0;
      if (a > 1) a = 1;

      // TEST ALPHA
      var dat = getNextTexturePixel(point.p);
      a = a * dat;

      // color
      var r = 35;
      var g = 35;
      var b = 60;

      // byte-index pixel placement within array
      // old * (1-a) + new * a
      var idx = (i + j * w) * 4;
      id.data[idx + 0] = id.data[idx + 0] * (1 - a) + r * a;
      id.data[idx + 1] = id.data[idx + 1] * (1 - a) + g * a;
      id.data[idx + 2] = id.data[idx + 2] * (1 - a) + b * a;
      id.data[idx + 3] = 255;
    }
  }
}

/*
∀ (x, y)
  T = (x / (w-1), y / (h-1))
  (s, t) = |(|(T - 1)| % 2 - 1)|
  >> (s * (w-1), t * (h-1))
Where x and y are your texture coordinates, which can be anywhere from
negative infinity to positive infinity in both x and y. The variables
w and h are the width and height of the texture.
*/
function getNextTexturePixel(p) {
  // Pick texture to use
  var texture = texture1;
  var textureImageData = textureImageData1;
  /*if(p > 0.5) {
    textureImageData = textureImageData1;
  } else {
    texture = texture1;
    textureImageData = textureImageData1;
  }*/

  // Get normalized pixel within texture
  var T_s = textureOffsetX / (texture.width - 1);
  var T_t = textureOffsetY / (texture.height - 1);
  var s = Math.abs(Math.abs(T_s - 1) % 2 - 1);
  var t = Math.abs(Math.abs(T_t - 1) % 2 - 1);
  var x = Math.floor(s * (texture.width - 1));
  var y = Math.floor(t * (texture.height - 1));
  var idx = (x + y * texture.width) * 4;
  var r = textureImageData[idx + 0];
  var g = textureImageData[idx + 1];
  var b = textureImageData[idx + 2];
  var l = (r + g + b) / 3; // crude average luminance
  if(p < 0.4) {
    l += 50; // lighter texture for grain
  }

  // Step texture offset randomly [-1, 1]
  var textureStep = getTextureStep();
  textureOffsetX += textureStep.x;
  textureOffsetY += textureStep.y;

  return (1 - l/255);
}

function getTextureStep() {
  var offset = {
    x: Math.floor(Math.random() * 2) === 1 ? -1 : 1,
    y: Math.floor(Math.random() * 2) === 1 ? -1 : 1,
  }
  return offset;
}

function getEventPoint(e) {
  var point = new Point(
    e.clientX - cursorOffsetX,
    e.clientY - cursorOffsetY,
    (useMouse ? 1: plugin.penAPI.pressure)
    //plugin.penAPI.pressure
  );
  return point;
}

function clearCanvas(){
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = paperColor;
  ctx.globalAlpha = 1;
  ctx.fillRect(0, 0, w, h);
  imageData = ctx.getImageData(0, 0, w, h);
}

// UTILS

Array.prototype.last = function(){
  return this[this.length - 1];
}

function map(value, valueMin, valueMax, from, to) {
  var ratio = (value - valueMin) / (valueMax - valueMin);
  return from + ratio * (to - from);
}

// POINT

function Point(x, y, p) {
  this.x = x;
  this.y = y;
  this.p = p;
}

Point.prototype.equals = function(pt) {
  return pt && this.x === pt.x && this.y === pt.y && this.p === pt.p;
}

Point.prototype.getMidPt = function(pt) {
  return new Point(
    (this.x + pt.x) / 2,
    (this.y + pt.y) / 2,
    (this.p + pt.p) / 2
  );
}

Point.prototype.getMirroredPt = function(pt) {
  return new Point(
    this.x + 2 * (pt.x - this.x),
    this.y + 2 * (pt.y - this.y),
    this.p + 2 * (pt.p - this.p)
  );
}

Point.prototype.getDistance = function(pt) {
  // TODO use Manhattan distance?
  var dx = this.x - pt.x;
  var dy = this.y - pt.y;
  return Math.sqrt(dx * dx + dy * dy);
}

</script>
</html>
