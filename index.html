<html>
  <head>
    <style>
      body {
        font-family: sans-serif;
      }
      canvas {
        float: left;
        cursor: url('cursors/cursor.cur'), crosshair;
        border: 1px solid gray;
      }
      img {
        display: none;
      }
      a {
        padding: 10px;
        line-height: 40px;
        cursor: pointer;
        color: white;
        text-decoration: none;
        user-select: none;
      }
      #capture {
        background: #25B380;
      }
      #clear {
        background: #DD3333;
      }
    </style>
  </head>

  <body>
    <canvas id="canvas"></canvas>
    <div id="buttons">
      <a id='capture'>Capture</a><br>
      <a id='clear'>Clear</a>
    </div>
    <img src="img/image0052-1-b5-4_sm-2.png" id="img"/>
    <object id="wtPlugin" type="application/x-wacomtabletplugin">
      <param name="onload" value="pluginLoaded" />
    </object>
  </body>
 
  <script>
    var w = 1300;
    var h = 1000;
    var ratio = 2;
    var cursorOffsetX = 12;
    var cursorOffsetY = 8;
    var isDrawing = false;
    var isSkipping = false;
    var skipCounter = 0;
    var penDownFrame = 0;
    var mouseMoveCounter = 0;
    var emptyInk = true;
    var points = [];
    var canvas;
    var button;
    var button2;
    var img;
    var plugin;
    var ctx;
    var pat;
    var x;
    var y;
    var px;
    var py;

    window.onload = function() {
      canvas = document.getElementById('canvas');
      button = document.getElementById('capture');
      button2 = document.getElementById('clear');
      img = document.getElementById("img");
      plugin = document.getElementById('wtPlugin');
      canvas.setAttribute('width', w * ratio);
      canvas.setAttribute('height', h * ratio);
      canvas.style.width = w;
      canvas.style.height = h;
      ctx = canvas.getContext('2d');
      pat = ctx.createPattern(img,"repeat");
      ctx.scale(ratio, ratio);
      ctx.strokeStyle = pat;
      clearCanvas();

      window.onkeypress = function(e) { 
        if (e.charCode === 105) {
          window.open(canvas.toDataURL());
        }
        if (e.charCode === 106) {
          var json = JSON.stringify(points);
          var blob = new Blob([json], {type: 'application/json'});
          var url  = URL.createObjectURL(blob);
          window.open(url);
        }
      }

      //////////////////////////
      // Buttons
      //////////////////////////

      button.onclick = function(e) {
        var json = JSON.stringify(points);
        var blob = new Blob([json], {type: 'application/json'});
        var url  = URL.createObjectURL(blob);
        button.download = 'capture_'+Date.now()+'.json';
        button.href = url;
        points.length = 0;
      }

      button2.onclick = function(e) {
        clearCanvas();
      }

      //////////////////////////
      // Input Capture
      //////////////////////////

      canvas.onmousedown = function(e) {
        isDrawing = true;
        penDownFrame = 0;
        recordPoint(e);
        px = x;
        py = y;
      };

      canvas.onmousemove = function(e) {
        var minx;
        var miny;
        var pressure;
        var point;
        mouseMoveCounter++;
        penDownFrame++;

        if (!(mouseMoveCounter % 2 === 0)){
          return;
        }

        if (!isDrawing) {
          return;
        }

        if (points.length > 10) {
          var lastPoint = points[points.length-1];
          points.push(lastPoint); // why do I have to duplicate the last point?
          drawCapture(points);
          points = [];
          points.push(lastPoint);
        }

        recordPoint(e);
        minx = Math.min(x, px) + Math.random()*50;
        miny = Math.min(y, py) + Math.random()*50;
        px = x;
        py = y;
      };

      canvas.onmouseup = function() {
        isDrawing = false;
        drawCapture(points);
        points = [];
      };
      
    }

    //////////////////////////
    // Inking
    //////////////////////////

    function drawCapture(pts) {
      if(pts.length > 2) {
        var area = getCurveArea(pts);
        var firstPoint = pts[0];
        var lastPoint = pts[pts.length-1];
        var elapsed = lastPoint.time - firstPoint.time;

        if((area > 100 && pts.length > 40) || elapsed < 200) {
          drawCurve(pts);
        } else {
          drawSegments(pts);
        }
      }
    }

    function drawSegments(pts) {
      var minpt;
      var minx;
      var miny;

      for(var i = 0; i < pts.length-1; i++) {
        px = pts[i].x;
        py = pts[i].y;
        x = pts[i+1].x;
        y = pts[i+1].y;

        minpt = getMinPt({x: px, y: py}, pts[i+1]);
        minx = minpt.x;
        miny = minpt.y;

        ctx.lineWidth = calcLineWidth(pts[i+1].p);
        ctx.globalAlpha = calcGlobalAlpha(pts[i+1].p);

        ctx.translate(minx, miny);
        ctx.beginPath();
        ctx.moveTo(px - minx, py - miny);
        ctx.lineTo(x - minx, y - miny);
        ctx.stroke();
        ctx.closePath();
        ctx.translate(-minx, -miny);
      }
    }

    function drawCurve(pts) {
      var p1 = pts[0];
      var p2 = pts[1];
      var from = p1;
      
      for (var i = 1; i < pts.length; i++) {
        if(p1) {
          var midPoint = getMidPt(p1, p2);
          var to = midPoint;
          var ctrl = p1;
          var a = [];
          //http://stackoverflow.com/questions/5634460/quadratic-bezier-curve-calculate-point
          for (var t = 0; t <= 1; t += 0.5) {
            var newPoint = {};
            newPoint.x = (1 - t) * (1 - t) * from.x + 2 * (1 - t) * t * ctrl.x + t * t * to.x;
            newPoint.y = (1 - t) * (1 - t) * from.y + 2 * (1 - t) * t * ctrl.y + t * t * to.y;
            newPoint.p = (from.p + to.p + ctrl.p) / 3;
            a.push(newPoint);
          }
          drawSegments(a);
        }
        p1 = pts[i];
        p2 = pts[i+1];
        from = midPoint;
      }
    }

    function calcLineWidth(p) {
      var width;

      if(p < 0.4) {
        width = ((p)/(0.4))*(0.7);
      } else {
        if((p >= 0.4) && (p < 0.7)) {
          width = ((p-0.4)/(0.3))*(2);
        } else {
          if((p >= 0.7) && (p < 0.9)) {
            width = 2.5;
          } else {
            if((p >= 0.9)) {
              width = 2.8;
            }
          }
        }
      }

      return width;
    }

    function calcGlobalAlpha(p) {
      var alpha;

      if(isSkipping && (skipCounter > 30)) {
        isSkipping = false;
        skipCounter = 0;
      }

      if(emptyInk) {
        isSkipping = true;
        emptyInk = false;
        window.setTimeout(function() {
          emptyInk = true;
        }, 2000);
      }

      if(isSkipping && p < 0.4) {
        alpha = 0.3+(skipCounter/100);
        skipCounter++;
      } else {
        if(p < 0.4) {
          alpha = 0.3;
        } else {
          alpha = 0.9;
        }
      }
      
      return alpha;
    }

    //////////////////////////
    // Point
    //////////////////////////

    function recordPoint(e) {
      x = e.clientX - cursorOffsetX;
      y = e.clientY - cursorOffsetY;

      point = {
        p   : plugin.penAPI.pressure,
        x   : x,
        y   : y,
        t   : Date.now()
      };
      points.push(point);
    }

    function getMinPt(p1, p2) {
      var minx = Math.min(p1.x, p2.x) + Math.random()*50;
      var miny = Math.min(p1.y, p2.y) + Math.random()*50;

      return {x: minx, y: miny};
    }

    function getMidPt(p1, p2) {
      return {
        canvasX: p1.x + (p2.x - p1.x) / 2,
        canvasY: p1.y + (p2.y - p1.y) / 2,
        pressure: (p1.p + p2.p) / 2
      };
    }

    function getCurveArea(pts) {
      var minX = pts[0].x;
      var minY = pts[0].y;
      var maxX = pts[0].x;
      var maxY = pts[0].y;
      var area;

      for(var i = 0; i < pts.length; i++) {
        minX = Math.min(minX, pts[i].x);
        minY = Math.min(minY, pts[i].y);
        maxX = Math.max(maxX, pts[i].x);
        maxY = Math.max(maxY, pts[i].y);
      }

      area = (maxX - minX)*(maxY - minY);

      return area;
    }

    //////////////////////////
    // Canvas
    //////////////////////////

    function clearCanvas(){
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = 'rgb(253, 254, 251)';
      ctx.globalAlpha = 1;
      ctx.fillRect(0, 0, w, h);
    }

  </script>

</html>