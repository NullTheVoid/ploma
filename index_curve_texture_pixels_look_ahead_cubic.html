<!--
  @TODO:
  - Find all original inspiration code
  - Add license?
  - CDG, SAP

  Empty Cursor website
  Dan Amelang's emails
  http://www.colourlovers.com/palette/3412827/21st
  http://pomax.github.io/bezierinfo/
  http://stackoverflow.com/questions/5634460/quadratic-bezier-curve-calculate-point
  http://math.stackexchange.com/questions/191672/cubic-bezier-curves-calculate-y-for-any-given-x
  http://books.google.com/books?id=8CGj9_ZlFKoC&lpg=PA199&ots=yB9xOx-sGF&dq=bezier%20control%20polygon%20length&pg=PA199#v=onepage&q=bezier%20control%20polygon%20length&f=false
  http://en.wikipedia.org/wiki/Alpha_compositing
  http://perfectionkills.com/exploring-canvas-drawing-techniques/#_=_

  @TODO:
  - Fix beginning/end width glitch
  - Add input filtering for the beginnings/ends?
  - Add texture
  - Add skipping
-->

<html>
<head>
<style>
body {
  font-family: sans-serif;
}
canvas {
  float: left;
  /*cursor: url('cursors/cursor.cur'), crosshair;*/
  cursor: none;
  /*cursor: crosshair;*/
  border: 1px solid gray;
}
img {
  display: none;
}
a {
  padding: 10px;
  line-height: 40px;
  cursor: pointer;
  color: white;
  text-decoration: none;
  -moz-user-select: none;
}
#save {
  background: #3B2D38;
}
#clear {
  background: #F02475;
}
#equation {
  width: 1242px;
  background: white;
  font-size: 18px;
  padding: 30px;
}
#equation input{
  width: 300px;
  height: 30px;
  font-size: 18px;
  border: 1px solid #CCC;
  padding: 2px;
}
</style>
</head>

<body>
<div id="equation">
  <center>
   <input value="0.2/(x - factor) - 0.12" id="expression"/> &nbsp;&nbsp;@&nbsp;&nbsp;
   <input value="0" id="width"/> w
   <input value="0.55" id="step">px
 </center>
</div>
<canvas id="canvas"></canvas>
<div id="buttons">
  <a id="save">Save</a>
  <br>
  <br>
  <br>
  <a id="clear">Clear</a>
</div>
<img src="img/circle_ballpoint_4.png" id="texture"/>
<object id="wtPlugin" type="application/x-wacomtabletplugin">
  <param name="onload" value="pluginLoaded"/>
</object>
</body>

<script>
// State
var w = 1300;
var h = 1000;
var sample = 1;
var cursorOffsetX = 5;
var cursorOffsetY = 0;
var points = [];
var storedPoints = [];
var curStrokePoints = [];
var isDrawing = false;
var mouseMoveCounter = 0;
var minx;
var maxx;
var miny;
var maxy;

// DOM
var canvas;
var imageData;
var offscreen;
var save;
var clear;
var texture;
var plugin;
var ctx;
var lastControlPoint;
var inputExpression;
var inputStep;
var inputWidth;

window.onload = function() {
  initDOMElements();
  initEvents();
  clearCanvas();
}

function initDOMElements() {canvas = document.getElementById('canvas');
  canvas.setAttribute('width', w);
  canvas.setAttribute('height', h);
  offscreen = document.createElement('canvas');
  offscreen.setAttribute('width', w);
  offscreen.setAttribute('height', h);
  save = document.getElementById('save');
  clear = document.getElementById('clear');
  texture = document.getElementById("texture");
  plugin = document.getElementById('wtPlugin');
  inputExpression = document.getElementById('expression');
  inputStep = document.getElementById('step');
  inputWidth = document.getElementById('width');
  ctx = canvas.getContext('2d');
  cursorOffsetY = document.getElementById('equation').clientHeight + 5;
}

function initEvents() {
  save.onclick = function(e) {
    window.open(canvas.toDataURL());
  }
  clear.onclick = function(e) {
    clearCanvas();
  }
  canvas.onmousedown = function(e) {
    isDrawing = true;
    curStrokePoints = [];
    recordPoint(e);
    mouseMoveCounter++;
  };
  canvas.onmousemove = function(e) {
    var self = this;
    mouseMoveCounter++;
    if (!isDrawing) return;
    if ((mouseMoveCounter % 7) !== 0) return;
    recordPoint(e);
    redraw();
  }
  canvas.onmouseup = function(e) {
    recordPoint(e);
    redraw(); // draw next to last curve
    drawCurve([points[0], points[1]]); // draw last curve
    isDrawing = false;
    points = [];
    lastControlPoint = null;
    storedPoints.push(curStrokePoints);
  };
}

function redraw() {
  if (!isDrawing) {
    return;
  }
  // 3 points needed for a look-ahead bezier
  if(points.length === 3) {
    var p1 = points[1];
    var p2 = points[2];
    drawCurve(points);
    points = [];
    points.push(p1);
    points.push(p2);
  }
};

// draws a cubic bezier according to 3 input points
function drawCurve(pts) {
  minx = w;
  miny = h;
  maxx = 0;
  maxy = 0;

  // endpoints and control points
  var p0 = pts[0];
  var p3 = pts[1];
  var p1;
  var p2;
  if(!lastControlPoint) {
    // first point
    p1 = {
      x: p0.x + (p3.x - p0.x) * 0.33,
      y: p0.y + (p3.y - p0.y) * 0.33
    };
  } else {
    p1 = getMirroredPt(lastControlPoint, p0);
  }
  if (points.length === 2) {
    // last point
    p2 = {
      x: p0.x + (p3.x - p0.x) * 0.66,
      y: p0.y + (p3.y - p0.y) * 0.66
    };
  } else {
    p2 = {
      x: p3.x - (((p3.x - p0.x) + (pts[2].x - p3.x)) / 2 / 3),
      y: p3.y - (((p3.y - p0.y) + (pts[2].y - p3.y)) / 2 / 3)
    };
  }
  lastControlPoint = p2;

  // length
  var bezierLength =
    (1/2) * getDistance(p0, p3) + 
    (1/2) * (getDistance(p0, p1) + getDistance(p1, p2) + getDistance(p2, p3))
  ;

  // pressure
  var p = (p0.p + p3.p)/2;

  // step length based on app input
  var stepLength = parseFloat(inputStep.value);

  // step along curve
  for(var t = 0; t < 1; t += (1/(bezierLength/stepLength))) {
    //(1-t)^3 * x0 + 3*(1-t)^2 * t * x1 + 3*(1-t) * t^2 * x2 + t^3 * x3
    var step_x = Math.pow((1-t),3)*p0.x + 3*Math.pow((1-t),2)*t*p1.x + 3*(1-t)*Math.pow(t,2)*p2.x + Math.pow(t,3)*p3.x;
    var step_y = Math.pow((1-t),3)*p0.y + 3*Math.pow((1-t),2)*t*p1.y + 3*(1-t)*Math.pow(t,2)*p2.y + Math.pow(t,3)*p3.y;
    var color;
    if(t === 0){
      color = 'red';
    } else {
      color = 'black';
    }
    drawPixel(imageData, step_x, step_y, p, color);
  }

  //ctx.putImageData(imageData, 0, 0);
  ctx.putImageData(imageData, 0, 0, minx, miny, maxx-minx+1, maxy-miny+1);
}

function drawPixel(id, x, y, p, color) {
  for(var i = -2; i < 3; i++) {
    for(var j = -2; j < 3; j++) {

      // distance
      minx = Math.min(minx, Math.round(x) + i);
      maxx = Math.max(maxx, Math.round(x) + i);
      miny = Math.min(miny, Math.round(y) + j);
      maxy = Math.max(maxy, Math.round(y) + j);

      var idx = ((Math.round(x) + i) + (Math.round(y) + j)*w)*4;
      var dist = getDistance(
        {x: x, y: y},
        {x: Math.round(x) + i, y: Math.round(y) + j}
      );

      p = 0;
      //p = 1;

      // antialiasing thin/thick
      var size = 1.12;
      var a = -0.2/(dist - size) + 1.12; // p = 0
      //var a = -0.1/(dist + 0.2) + 1.04;
      //var a = -0.1/(dist - 1.30) + 1.03; // p = 1

      // antialiasing and feathering
      /*var slope = map(p, 0, 1, -0.2, -0.1);
      var size = map(p, 0, 1, -0.12, 1.3);
      var offset = map(p, 0, 1, 1.12, 1.03);
      var a = slope/(dist - size) + offset;*/
      if(dist < size) {
        a = 0;
      }

      // non-saturating
      if(a < 0.25) {
        a = 0.25;
      }
      
      // clamp alpha
      if (a < 0) a = 0; // opaque
      if (a > 1) a = 1; // transparent

      // color for debugging
      var r, g, b;
      if(color === 'red') {
        r = 255;
        g = 00;
        b = 00;
      } else {
        r = 00;
        g = 00;
        b = 50;
      }

      // pixel placement within array
      id.data[idx + 0] = id.data[idx + 0] * a + r * a * (1 - a);
      id.data[idx + 1] = id.data[idx + 1] * a + g * a * (1 - a);
      id.data[idx + 2] = id.data[idx + 2] * a + b * a * (1 - a);
      id.data[idx + 3] = 255;
    }
  }
}

function recordPoint(e) {
  point = {
    x   : e.clientX - cursorOffsetX,
    y   : e.clientY - cursorOffsetY,
    p   : (plugin ? plugin.penAPI.pressure : 1)
  };
  points.push(point);
  curStrokePoints.push(point);
}

function clearCanvas(){
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = 'rgb(253, 254, 251)';
  ctx.globalAlpha = 1;
  ctx.fillRect(0, 0, w, h);
  imageData = ctx.getImageData(0, 0, w, h);
}

// UTILS

function getMidPt(p1, p2) {
  return {
    x: (p1.x + p2.x) / 2,
    y: (p1.y + p2.y) / 2
  };
}

function getMirroredPt(p1, p2) {
  return {
    x: 2*p2.x - p1.x,
    y: 2*p2.y - p1.y
  }
}

function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function map(value, valueMin, valueMax, from, to) {
  var ratio = (value - valueMin) / (valueMax - valueMin);
  return from + ratio * (to - from);
}

</script>
</html>