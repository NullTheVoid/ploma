<!--
  @TODO: Find all original inspiration code

  Empty Cursor website

  Color Palette
  http://www.colourlovers.com/palette/3412827/21st

  Bezier Tangent End Point
  Bezier mirrored control points
  ???
  http://pomax.github.io/bezierinfo/

  Bezier Equation from StackOverflow
  http://stackoverflow.com/questions/5634460/quadratic-bezier-curve-calculate-point
  http://math.stackexchange.com/questions/191672/cubic-bezier-curves-calculate-y-for-any-given-x

  Bezier Length
  http://books.google.com/books?id=8CGj9_ZlFKoC&lpg=PA199&ots=yB9xOx-sGF&dq=bezier%20control%20polygon%20length&pg=PA199#v=onepage&q=bezier%20control%20polygon%20length&f=false

  Alpha Compositing
  http://en.wikipedia.org/wiki/Alpha_compositing

  Line Scattering and General Techniques
  http://perfectionkills.com/exploring-canvas-drawing-techniques/#_=_

  Convolution/sharpness

  Convolution/contrast

  Wacom SDK?

  TODO:
  - add final lookahead point
  - add variable width
  - add texture
  - add skipping

-->

<html>
<head>
<style>
body {
  font-family: sans-serif;
}
canvas {
  float: left;
  cursor: url('cursors/cursor.cur'), crosshair;
  border: 1px solid gray;
}
img {
  display: none;
}
a {
  padding: 10px;
  line-height: 40px;
  cursor: pointer;
  color: white;
  text-decoration: none;
  -moz-user-select: none;
}
#save {
  background: #3B2D38;
}
#clear {
  background: #F02475;
}
#equation {
  width: 1242px;
  background: beige;
  font-size: 24px;
  padding: 30px;
}
#equation input{
  width: 100px;
  height: 40px;
  font-size: 24px;
}
</style>
</head>

<body>
<div id="equation">
  <center>
   <input value="-0.2" id="a" /> / ( x + <input value="-0.12" id="b" /> ) + <input value="1.12" id="c"/> &nbsp;&nbsp;@&nbsp;&nbsp; <input value="1" id="stepA"> / <input value="1.6" id="stepB"/> dt
 </center>
</div>
<canvas id="canvas"></canvas>
<div id="buttons">
  <a id="save">Save</a>
  <br>
  <br>
  <br>
  <a id="clear">Clear</a>
</div>
<img src="img/circle_ballpoint_4.png" id="texture"/>
<object id="wtPlugin" type="application/x-wacomtabletplugin">
  <param name="onload" value="pluginLoaded"/>
</object>
</body>

<script>
// State
var w = 1300;
var h = 1000;
var ratio = 1;
var sample = 1;
var cursorOffsetX = 13;
var cursorOffsetY = 3;
var points = [];
var isDrawing = false;
var mouseMoveCounter = 0;

// DOM
var canvas;
var save;
var clear;
var texture;
var textureImageData;
var plugin;
var ctx;
var lastControlPoint;
var inputA;
var inputB;
var inputC;
var inputStepA;
var inputStepB;

window.onload = function() {
  initDOMElements();
  initEvents();
  clearCanvas();
}

function initDOMElements() {canvas = document.getElementById('canvas');
  canvas.setAttribute('width', w * ratio);
  canvas.setAttribute('height', h * ratio);
  canvas.style.width = w;
  canvas.style.height = h;
  save = document.getElementById('save');
  clear = document.getElementById('clear');
  texture = document.getElementById("texture");
  plugin = document.getElementById('wtPlugin');
  inputA = document.getElementById('a');
  inputB = document.getElementById('b');
  inputC = document.getElementById('c');
  inputStepA = document.getElementById('stepA');
  inputStepB = document.getElementById('stepB');
  ctx = canvas.getContext('2d');
  ctx.scale(ratio, ratio);
  cursorOffsetY = document.getElementById('equation').clientHeight + 5;
}

function initEvents() {
  save.onclick = function(e) {
    window.open(canvas.toDataURL());
  }
  clear.onclick = function(e) {
    clearCanvas();
  }
  canvas.onmousedown = function(e) {
    isDrawing = true;    recordPoint(e);
    mouseMoveCounter++;
  };
  canvas.onmousemove = function(e) {
    var self = this;
    mouseMoveCounter++;
    if (!isDrawing) return;
    if ((mouseMoveCounter % 5) !== 0) return;
    recordPoint(e);
    redraw();
  }
  canvas.onmouseup = function(e) {
    isDrawing = false;
    //recordPoint(e);
    points = [];
    lastControlPoint = null;
  };
}

function redraw() {
  if (!isDrawing) {
    return;
  }
  // 3 points needed for a look-ahead cubic bezier
  if(points.length === 3) {
    var p1 = points[1];
    var p2 = points[2];
    drawCurve(points);
    points = [];
    points.push(p1);
    points.push(p2);
  }
};

// draws a quadratic bezier according to 3 input points
function drawCurve(pts) {
  var imageData = ctx.getImageData(0, 0, w * ratio, h * ratio);

  /*
  (c) 2014 Dan Amelang

  Let "Q" be the look ahead coordinate (i.e., input event coordinate
  number "n - 1", the most recent one)

  p0 = (input event coordinate number n - 3)
  p1 = (the previous Bezier's p2 mirrored across this Bezier's p0)
  p2 = p3 - (((p3 - p0) + (Q - p3)) / 2 / 3);
  p3 = (input event coordinate number n - 2)

  For the first Bezier in the path, there is no "previous Bezier", so
  you can just do this for the first Bezier's p1:

  p1 = p0 + (p3 - p0) * 0.33;

  And for the last Bezier, there is no look ahead point, so you can just
  do this for the last Bezier's p2:

  p2 = p0 + (p3 - p0) * 0.66;

  approximateLength = 0.5 * chordLength + 0.5 * polygonLength

  where

  chordLength = distanceBetween(p0, p3)

  polygonLength = distanceBetween(p0, p1) + distanceBetween(p1, p2) +
  distanceBetween(p2, p3)
  */
  
  // endpoints
  var p0 = pts[0];
  var p3 = pts[1];

  // control points
  if(!lastControlPoint) {
    lastControlPoint = {
      x: p0.x + (p3.x - p0.x) * 0.33,
      y: p0.y + (p3.y - p0.y) * 0.33
    };
  }
  var p1 = getMirroredPt(lastControlPoint, p0);
  var p2 = {
    x: p3.x - (((p3.x - p0.x) + (pts[2].x - p3.x)) / 2 / 3),
    y: p3.y - (((p3.y - p0.y) + (pts[2].y - p3.y)) / 2 / 3)
  };
  lastControlPoint = p2;

  // length
  var bezierLength =
    (1/2) * getDistance(p0, p3) + 
    (1/2) * (getDistance(p0, p1) + getDistance(p1, p2) + getDistance(p2, p3))
  ;
  var stepLength = 0.6;

  // pressure
  var p = (p0.p + p3.p)/2;

  for(var t = 0; t < 1; t += (1/(bezierLength/stepLength))) {
    //(1-t)^3 * x0 + 3*(1-t)^2 * t * x1 + 3*(1-t) * t^2 * x2 + t^3 * x3
    var step_x = Math.pow((1-t),3)*p0.x + 3*Math.pow((1-t),2)*t*p1.x + 3*(1-t)*Math.pow(t,2)*p2.x + Math.pow(t,3)*p3.x;
    var step_y = Math.pow((1-t),3)*p0.y + 3*Math.pow((1-t),2)*t*p1.y + 3*(1-t)*Math.pow(t,2)*p2.y + Math.pow(t,3)*p3.y;
    drawPixel(imageData, step_x, step_y, p);
  }

  ctx.putImageData(imageData, 0, 0);
}

function drawPixel(id, x, y, p, delta) {
  for(var i = -1; i < 2; i++) {
    for(var j = -1; j < 2; j++) {

      var idx = ((Math.round(x) + i) + (Math.round(y) + j)*w*ratio)*4;
      var dist = getDistance({x: x, y: y}, {x: Math.round(x) + i, y: Math.round(y) + j});

      var a = -0.2/(dist-0.12)+1.12;
      
      if (a < 0) a = 0; // a = 0 = opaque
      if (a > 1) a = 1; // a = 1 = transparent

      id.data[idx + 0] = id.data[idx + 0] * a + 00 * a * (1 - a);
      id.data[idx + 1] = id.data[idx + 1] * a + 00 * a * (1 - a);
      id.data[idx + 2] = id.data[idx + 2] * a + 50 * a * (1 - a);
      id.data[idx + 3] = 255;
    }
  }
}

function recordPoint(e) {
  point = {
    x   : e.clientX - cursorOffsetX,
    y   : e.clientY - cursorOffsetY,
    p   : plugin.penAPI.pressure
  };
  points.push(point);
}

function clearCanvas(){
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = 'rgb(253, 254, 251)';
  ctx.globalAlpha = 1;
  ctx.fillRect(0, 0, w, h);
}

// UTILS

function getMidPt(p1, p2) {
  return {
    x: (p1.x + p2.x) / 2,
    y: (p1.y + p2.y) / 2
  };
}

function getMirroredPt(p1, p2) {
  // mirror A through B (2Bx−Ax, 2By−Ay)
  return {
    x: 2*p2.x - p1.x,
    y: 2*p2.y - p1.y
  }
}

function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

</script>
</html>