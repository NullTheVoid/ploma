<!--
  @TODO: Find all original inspiration code

  Empty Cursor website

  Color Palette
  http://www.colourlovers.com/palette/3412827/21st

  Bezier Tangent End Point
  ???
  http://pomax.github.io/bezierinfo/

  Bezier Equation from StackOverflow
  http://stackoverflow.com/questions/5634460/quadratic-bezier-curve-calculate-point

  Bezier Length
  http://books.google.com/books?id=8CGj9_ZlFKoC&lpg=PA199&ots=yB9xOx-sGF&dq=bezier%20control%20polygon%20length&pg=PA199#v=onepage&q=bezier%20control%20polygon%20length&f=false

  Alpha Compositing
  http://en.wikipedia.org/wiki/Alpha_compositing

  Line Scattering and General Techniques
  http://perfectionkills.com/exploring-canvas-drawing-techniques/#_=_

  Convolution/sharpness

  Convolution/contrast

  Wacom SDK?

-->

<html>
<head>
<style>
body {
  font-family: sans-serif;
}
canvas {
  float: left;
  cursor: url('cursors/cursor.cur'), crosshair;
  border: 1px solid gray;
}
img {
  display: none;
}
a {
  padding: 10px;
  line-height: 40px;
  cursor: pointer;
  color: white;
  text-decoration: none;
  -moz-user-select: none;
}
#save {
  background: #3B2D38;
}
#clear {
  background: #F02475;
}
</style>
</head>

<body>
<canvas id="canvas"></canvas>
<div id="buttons">
  <a id="save">Save</a>
  <br>
  <br>
  <br>
  <a id="clear">Clear</a>
</div>
<img src="img/circle_ballpoint_4.png" id="texture"/>
<object id="wtPlugin" type="application/x-wacomtabletplugin">
  <param name="onload" value="pluginLoaded"/>
</object>
</body>

<script>
// State
var w = 1300;
var h = 1000;
var ratio = 1;
var sample = 1;
var cursorOffsetX = 13;
var cursorOffsetY = 3;
var points = [];
var isDrawing = false;

// DOM
var canvas;
var save;
var clear;
var texture;
var textureImageData;
var plugin;
var ctx;
var lastControlPoint;

window.onload = function() {
  initDOMElements();
  initEvents();
  clearCanvas();
}

function initDOMElements() {canvas = document.getElementById('canvas');
  canvas.setAttribute('width', w * ratio);
  canvas.setAttribute('height', h * ratio);
  canvas.style.width = w;
  canvas.style.height = h;
  save = document.getElementById('save');
  clear = document.getElementById('clear');
  texture = document.getElementById("texture");
  plugin = document.getElementById('wtPlugin');
  ctx = canvas.getContext('2d');
  ctx.scale(ratio, ratio);

  // texture image data
  var wt = texture.width;
  var ht = texture.height;
  var c = document.createElement('canvas');
  var x = c.getContext('2d');
  c.style.width = wt;
  c.style.height = ht;
  x.drawImage(texture, 0, 0);
  textureImageData = x.getImageData(0,0,wt,ht);
  textureImageData = textureImageData.data;
  //console.log(textureImageData);
}

function initEvents() {
  save.onclick = function(e) {
    window.open(canvas.toDataURL());
  }
  clear.onclick = function(e) {
    clearCanvas();
  }
  canvas.onmousedown = function(e) {
    isDrawing = true;    recordPoint(e);
  };
  canvas.onmousemove = function(e) {
    var self = this;
    if (!isDrawing) return;
    recordPoint(e);
    redraw();
  }
  canvas.onmouseup = function(e) {
    isDrawing = false;
    //recordPoint(e);
    points = [];
    lastControlPoint = null;
  };
}

function redraw() {
  if (!isDrawing) {
    return;
  }
  // 3 points needed for a quadratic bezier
  if(points.length === 2) {
    var lastPoint = points[points.length - 1];  // TODO: change control point math
    drawCurve(points);
    points = [];
    points.push(lastPoint);                     // TODO: change control point math
  }
};

// draws a quadratic bezier according to 3 input points
function drawCurve(pts) {
  var imageData = ctx.getImageData(0, 0, w * ratio, h * ratio);
  var from = pts[0];                            // TODO: change control point math
  var ctrl = lastControlPoint ? {x: 2*pts[0].x - lastControlPoint.x, y: 2*pts[0].y - lastControlPoint.y} : getMidPt(pts[0], pts[1]);
  var to = pts[1];                              // TODO: change control point math
  lastControlPoint = ctrl;
  //console.log(lastControlPoint);

  //Mirrored = (2Bx−Ax, 2By−Ay)
  // controlPoint2.x = 2*EndPoint.x - controlPoint1.x;
  // controlPoint2.y = 2*EndPoint.y - controlPoint1.y;

  // bezier length
  var bezierLength = (2/3)*getDistance(from, to) + (1/3)*(getDistance(from, ctrl) + getDistance(ctrl, to)); // Dan Amelang

  var p = (from.p + ctrl.p + to.p) / 3;
  var spread;
  var stepLength;
  var numPoints;
  var alpha;

  p = 0.67;
  // look up rendering values
  if(p < 0.2) {
    spread = 0.45;
    stepLength = 0.5;
    numPoints = 6;
    alpha = 0.98;
  }
  if((p >= 0.2) && (p < 0.3)) {
    spread = 0.55;
    stepLength = 0.45;
    numPoints = 6;
    alpha = 0.96;
  }
  if((p >= 0.3) && (p < 0.4)) {
    spread = 0.85;
    stepLength = 0.35;
    numPoints = 6;
    alpha = 0.94;
  }
  if((p >= 0.4) && (p < 0.5)) {
    spread = 1.05;
    stepLength = 0.25;
    numPoints = 5;
    alpha = 0.92;
  }
  if((p >= 0.5) && (p < 0.95)) {
    spread = 1.30;
    stepLength = 1;
    numPoints = p;
    alpha = 0.95;
  }
  if(p >= 0.95) {
    spread = 1.45;
    stepLength = 0.25;
    numPoints = 35;
    alpha = 0.9;
  }

  /*if(Math.floor(Math.random()*70) === 5) {
    alpha = 0.99;
  } else {
    if(Math.floor(Math.random()*70) === 4) {
      alpha = alpha-0.2;
    }
  }*/

  // step along bezier
  var alphaDelta = Math.random();
  for (var t = 0; t <= 1; t += (1/(bezierLength/stepLength))) {
    // calculate point along quadratic bezier
    var newPoint = {};
    newPoint.x = (1 - t) * (1 - t) * from.x + 2 * (1 - t) * t * ctrl.x + t * t * to.x;
    newPoint.y = (1 - t) * (1 - t) * from.y + 2 * (1 - t) * t * ctrl.y + t * t * to.y;
    newPoint.p = p;

    // TEST RANDOM SCATTER
    /*
    for(var i = 0; i < numPoints; i++){
      // scatter
      var scatterX = -spread + Math.random()*spread*2;
      var scatterY = -spread + Math.random()*spread*2;
      var index = (Math.floor(newPoint.x + scatterX) + Math.floor(newPoint.y + scatterY) * w * ratio)*4;

      // over blending26, 21, 51
      imageData.data[index + 0] = imageData.data[index + 0] * alpha + 26 * alpha * (1 - alpha);
      imageData.data[index + 1] = imageData.data[index + 1] * alpha + 21 * alpha * (1 - alpha);
      imageData.data[index + 2] = imageData.data[index + 2] * alpha + 51 * alpha * (1 - alpha);
      imageData.data[index + 3] = 255;
    }
    */

    // TEST [size x size] TEXTURE FILL
    var size = 4;
    var theta = Math.random()*Math.PI + Math.random()*Math.PI;
    theta = 0;
    for(var i = 0; i < size; i++) {
      var pixelX = Math.floor(newPoint.x) + i;
      for(var j = 0; j < size; j++) {
        var pixelY = Math.floor(newPoint.y) + j;
        //console.log(i);
        var rotatedPixel = getRotatedPt({x: (size-1)/2, y: (size-1)/2}, {x: i, y: j}, theta);
        //var rotatedPixel = getRotatedPt({x: (size/2)-1, y: (size/2)-1}, {x: i, y: j}, theta);
        //console.log('i: ' + i + ' j: ' + j);
        //console.log('x: ' + rotatedPixel.x + ' y: ' + rotatedPixel.y);
        pixelX = Math.floor(newPoint.x) + Math.floor(rotatedPixel.x);
        pixelY = Math.floor(newPoint.y) + Math.floor(rotatedPixel.y);
        var index = (pixelX + pixelY*w*ratio)*4;
        //var index = (rotatedPixel.x + rotatedPixel.y*w*ratio)*4;
        var idIndex = (i + j*size)*4;
        var alpha = textureImageData[idIndex + 3]/255;
        if(alpha < 0.6) {
          //console.log(alpha);
          imageData.data[index + 0] = imageData.data[index + 0];
          imageData.data[index + 1] = imageData.data[index + 1];
          imageData.data[index + 2] = imageData.data[index + 2];
        } else {
          alpha -= alphaDelta;
          alpha = Math.min(1, alpha);
          alpha = Math.max(0.6, alpha);
          //alpha = 1;
          imageData.data[index + 0] = imageData.data[index + 0] * alpha + 26 * alpha * (1 - alpha);
          imageData.data[index + 1] = imageData.data[index + 1] * alpha + 21 * alpha * (1 - alpha);
          imageData.data[index + 2] = imageData.data[index + 2] * alpha + 51 * alpha * (1 - alpha);
        }
        imageData.data[index + 3] = 255;
      }
    }
  }
  ctx.putImageData(imageData, 0, 0);
}

function recordPoint(e) {
  point = {
    x   : e.clientX - cursorOffsetX,
    y   : e.clientY - cursorOffsetY,
    p   : plugin.penAPI.pressure
  };
  points.push(point);
}

function clearCanvas(){
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = 'rgb(253, 254, 251)';
  ctx.globalAlpha = 1;
  ctx.fillRect(0, 0, w, h);
}

// UTILS

function getMidPt(p1, p2) {
  return {
    x: p1.x + (p2.x - p1.x) / 2,
    y: p1.y + (p2.y - p1.y) / 2,
    p: (p1.p + p2.p) / 2
  };
}

function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function getRotatedPt(p0, p1, theta) {
   var p2 = {};
   p2.x = Math.cos(theta) * (p1.x - p0.x) - Math.sin(theta) * (p1.y - p0.y) + p0.x;
   p2.y = Math.sin(theta) * (p1.x - p0.x) + Math.cos(theta) * (p1.y - p0.y) + p0.y;
   return p2;
}

</script>
</html>