// Generated by CoffeeScript 1.6.3
/*

Implementation of short straws
http://www.cs.ucf.edu/courses/cap6105/readings/Wolin_Eoff_Hammond_SBIM08.pdf
*/


(function() {
  var Circle, Graph, Line, Primitive, analyze, angleBetweenPoints, canvasEl, circleFitMaxError, clear, ctx, distanceBetweenPoints, drawCircle, drawCircleOutline, drawLine, findCorners, fitCircle, fitLine, fitPrimitives, n, pointerDown, pointerIsDown, pointerMove, pointerUp, quadranceBetweenPoints, resize, samples, startTime, transitionCost,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  findCorners = function(samples) {};

  /*
  
  Given a set of sample points [[x, y], ...] returns a circle as {center: [x, y], radius: r}
  
  via
  http://people.csail.mit.edu/ibaran/papers/2010-EG-Curves.pdf
  
  The idea is to lift each sample [x, y] onto the paraboloid defined by:
  
  z = x^2 + y^2
  
  We then fit a plane to this collection of 3D point samples. That plane
  intersects the paraboloid as an ellipse which projects down to the XY plane as
  the fitted circle.
  */


  fitCircle = function(samples) {
    var center, circle, intersectPlaneWithParaboloid, matrixSum, mean, n, normal, normalizedSample, originXY, paraboloidProject, projectedSample, projectedSampleT, sample, sampleMatrix, vectorSum, _i, _len;
    n = numeric;
    paraboloidProject = function(point) {
      /*
      
      paraboloidProject(point) projects a 2D [x, y] point onto the paraboloid,
      returning a 3D point.
      */

      var x, y;
      x = point[0], y = point[1];
      return [x, y, x * x + y * y];
    };
    intersectPlaneWithParaboloid = function(pointOnPlane, normal) {
      /*
      
      This function intersects a plane (given by a pointOnPlane and the normal
      vector) with the paraboloid. This intersection is an ellipse which
      projects as a circle onto the XY plane. We return this circle as {center,
      radius}
      
      First we find the equation for the plane in terms of:
      
      a*x + b*y + c*z = d
      
      We know for any point on the plane p,
      
      normal âˆ™ (p - pointOnPlane) = 0
      
      So,
      */

      var a, b, c, d, r, x0, y0;
      a = normal[0];
      b = normal[1];
      c = normal[2];
      d = n.dot(normal, pointOnPlane);
      /*
      
      Our equation for the paraboloid is:
      
      x^2 + y^2 = z
      
      Substituting for z using our equation for the plane,
      
      x^2 + y^2 = (d - a*x - b*y) / c
      
      Rearranging x and y to the lhs,
      
      x^2 + (a/c)*x + y^2 + (b/c)*y = d/c
      
      Recall that a circle of radius r centered at (x0, y0) has equation:
      
      (x - x0)^2 + (y - y0)^2 = r^2
      
      x^2 - 2*x0*x + x0^2 + y^2 - 2*y0*y + y0^2 = r^2
      
      x^2 - 2*x0*x + y^2 - 2*y0*y = r^2 - x0^2 - y0^2
      
      So we know that:
      
      a/c = -2*x0
      
      b/c = -2*y0
      
      d/c = r^2 - x0^2 - y0^2
      */

      x0 = -(a / c) / 2;
      y0 = -(b / c) / 2;
      r = Math.sqrt((d / c) + x0 * x0 + y0 * y0);
      return {
        center: [x0, y0],
        radius: r
      };
    };
    originXY = samples[0];
    vectorSum = [0, 0, 0];
    matrixSum = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
    for (_i = 0, _len = samples.length; _i < _len; _i++) {
      sample = samples[_i];
      normalizedSample = n.sub(sample, originXY);
      projectedSample = paraboloidProject(normalizedSample);
      n.addeq(vectorSum, projectedSample);
      projectedSample = [projectedSample];
      projectedSampleT = n.transpose(projectedSample);
      sampleMatrix = n.dot(projectedSampleT, projectedSample);
      n.addeq(matrixSum, sampleMatrix);
    }
    mean = n.div(vectorSum, samples.length);
    normal = n.eigen(matrixSum)[2].eigenvector;
    circle = intersectPlaneWithParaboloid(mean, normal);
    center = n.add(originXY, circle.center);
    return new Circle(center, circle.radius);
  };

  /*
  
  via
  http://people.csail.mit.edu/ibaran/papers/2010-EG-Curves.pdf
  */


  fitLine = function(samples) {
    var deviation, deviationT, direction, eigen, matrixSum, mean, n, sample, sampleMatrix, _i, _len;
    n = numeric;
    mean = n.mean(samples);
    matrixSum = [[0, 0], [0, 0]];
    for (_i = 0, _len = samples.length; _i < _len; _i++) {
      sample = samples[_i];
      deviation = n.sub(sample, mean);
      deviation = [deviation];
      deviationT = n.transpose(deviation);
      sampleMatrix = n.dot(deviationT, deviation);
      n.addeq(matrixSum, sampleMatrix);
    }
    eigen = n.eigen(matrixSum);
    direction = eigen[0].eigenvector;
    return new Line(mean, direction);
  };

  canvasEl = document.querySelector("#c");

  ctx = canvasEl.getContext("2d");

  resize = function() {
    var rect;
    rect = canvasEl.getBoundingClientRect();
    canvasEl.width = rect.width;
    return canvasEl.height = rect.height;
  };

  window.addEventListener("resize", resize);

  resize();

  pointerIsDown = false;

  startTime = 0;

  samples = [];

  pointerDown = function(e) {
    clear();
    pointerIsDown = true;
    startTime = Date.now();
    return samples = [];
  };

  pointerMove = function(e) {
    var sample, t, x, y;
    if (!pointerIsDown) {
      return;
    }
    x = e.clientX;
    y = e.clientY;
    t = Date.now() - startTime;
    sample = [x, y];
    drawCircle(sample);
    return samples.push(sample);
  };

  pointerUp = function(e) {
    pointerIsDown = false;
    return analyze(samples);
  };

  canvasEl.addEventListener("pointerdown", pointerDown);

  canvasEl.addEventListener("pointermove", pointerMove);

  canvasEl.addEventListener("pointerup", pointerUp);

  clear = function() {
    var height, width;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    width = ctx.canvas.width;
    height = ctx.canvas.height;
    ctx.clearRect(0, 0, width, height);
    return ctx.restore();
  };

  drawCircle = function(point, radius, color) {
    if (radius == null) {
      radius = 2.5;
    }
    if (color == null) {
      color = "#f00";
    }
    ctx.beginPath();
    ctx.arc(point[0], point[1], radius, 0, Math.PI * 2);
    ctx.fillStyle = color;
    return ctx.fill();
  };

  drawCircleOutline = function(point, radius, width, color) {
    if (width == null) {
      width = 1;
    }
    if (color == null) {
      color = "blue";
    }
    ctx.beginPath();
    ctx.arc(point[0], point[1], radius, 0, Math.PI * 2);
    ctx.lineWidth = width;
    ctx.strokeStyle = color;
    return ctx.stroke();
  };

  drawLine = function(startPoint, endPoint, width, color) {
    if (width == null) {
      width = 1;
    }
    if (color == null) {
      color = "green";
    }
    ctx.beginPath();
    ctx.moveTo(startPoint[0], startPoint[1]);
    ctx.lineTo(endPoint[0], endPoint[1]);
    ctx.lineWidth = width;
    ctx.strokeStyle = color;
    return ctx.stroke();
  };

  Primitive = (function() {
    function Primitive() {}

    Primitive.prototype.distanceToPoint = function(p) {};

    Primitive.prototype.maxError = function(samples) {
      var error, sample, _i, _len;
      error = 0;
      for (_i = 0, _len = samples.length; _i < _len; _i++) {
        sample = samples[_i];
        error = Math.max(error, this.distanceToPoint(sample));
      }
      return error;
    };

    Primitive.prototype.hasPrecisionProblems = function() {
      return false;
    };

    return Primitive;

  })();

  Circle = (function(_super) {
    __extends(Circle, _super);

    function Circle(center, radius) {
      this.center = center;
      this.radius = radius;
    }

    Circle.prototype.distanceToPoint = function(p) {
      var distance;
      distance = distanceBetweenPoints(p, this.center);
      return Math.abs(distance - this.radius);
    };

    Circle.prototype.draw = function() {
      return drawCircleOutline(this.center, this.radius);
    };

    Circle.prototype.hasPrecisionProblems = function() {
      return this.radius > 1000;
    };

    return Circle;

  })(Primitive);

  Line = (function(_super) {
    __extends(Line, _super);

    function Line(start, direction) {
      this.start = start;
      this.direction = direction;
      this.direction = n.div(this.direction, n.norm2(this.direction));
    }

    Line.prototype.distanceToPoint = function(p) {
      var parallelComponent, perpendicularComponent, v;
      v = n.sub(p, this.start);
      parallelComponent = n.mul(n.dot(this.direction, v), this.direction);
      perpendicularComponent = n.sub(v, parallelComponent);
      return n.norm2(perpendicularComponent);
    };

    Line.prototype.draw = function() {
      var end, extension, start;
      extension = n.mul(this.direction, 1000);
      start = n.add(this.start, extension);
      end = n.sub(this.start, extension);
      return drawLine(start, end);
    };

    return Line;

  })(Primitive);

  fitPrimitives = function(samples) {
    var helper, primitives;
    primitives = [];
    helper = function(fitFn) {
      var error, i, j, primitive, sampleRun, _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = samples.length - 2; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _ref2, _results1;
          _results1 = [];
          for (j = _j = _ref1 = i + 3, _ref2 = samples.length; _ref1 <= _ref2 ? _j <= _ref2 : _j >= _ref2; j = _ref1 <= _ref2 ? ++_j : --_j) {
            sampleRun = samples.slice(i, j);
            primitive = fitFn(sampleRun);
            error = primitive.maxError(sampleRun);
            if (error > 5 || primitive.hasPrecisionProblems()) {
              break;
            }
            primitive.i = i;
            primitive.j = j;
            primitive.error = error;
            _results1.push(primitives.push(primitive));
          }
          return _results1;
        })());
      }
      return _results;
    };
    helper(fitLine);
    helper(fitCircle);
    return primitives;
  };

  transitionCost = function(p1, p2) {
    var distance, error1, error2;
    if (p1 instanceof Circle && p2 instanceof Circle) {
      distance = distanceBetweenPoints(p1.center, p2.center);
      error1 = Math.abs(Math.abs(p1.radius - p2.radius) - distance);
      error2 = Math.abs(p1.radius + p2.radius - distance);
      return Math.min(error1, error2);
    } else if (p1 instanceof Circle && p2 instanceof Line) {
      distance = p2.distanceToPoint(p1.center);
      return Math.abs(p1.radius - distance);
    } else if (p1 instanceof Line && p2 instanceof Circle) {
      return transitionCost(p2, p1);
    } else {
      return Infinity;
    }
  };

  Graph = (function() {
    function Graph() {
      this.vertices = [];
    }

    Graph.prototype.addVertex = function(v) {
      this.vertices.push(v);
      v.edges = [];
      return v;
    };

    Graph.prototype.addEdge = function(v1, v2, weight) {
      return v1.edges.push({
        to: v2,
        weight: weight
      });
    };

    Graph.prototype.findShortestPath = function(source, target) {
      var alt, edge, path, q, u, v, vertex, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.vertices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        vertex = _ref[_i];
        vertex.distanceFromSource = Infinity;
        vertex.previous = void 0;
      }
      source.distanceFromSource = 0;
      q = _.clone(this.vertices);
      while (q.length > 0) {
        u = _.min(q, function(vertex) {
          return vertex.distanceFromSource;
        });
        if (u === Infinity || u.distanceFromSource === Infinity) {
          break;
        }
        q = _.without(q, u);
        _ref1 = u.edges;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          edge = _ref1[_j];
          v = edge.to;
          if (_.contains(q, v)) {
            alt = u.distanceFromSource + edge.weight;
            if (alt < v.distanceFromSource) {
              v.distanceFromSource = alt;
              v.previous = u;
            }
          }
        }
      }
      if (target.distanceFromSource === Infinity) {
        console.error("No path!");
      }
      path = [target];
      while (true) {
        vertex = path[0];
        if (vertex === source) {
          break;
        }
        path.unshift(vertex.previous);
      }
      return path;
    };

    return Graph;

  })();

  n = numeric;

  analyze = function(samples) {
    var adjusted, adjustedPath, current, distance, end, graph, i, parallelComponent, path, perpendicularComponent, perpendicularDirection, possibleRadiuses, possibleStarts, previous, primitive, primitives, radius, source, start, target, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _results;
    primitives = fitPrimitives(samples);
    graph = new Graph();
    source = graph.addVertex({});
    target = graph.addVertex({});
    for (_i = 0, _len = primitives.length; _i < _len; _i++) {
      primitive = primitives[_i];
      graph.addVertex(primitive);
      if (primitive.i === 0) {
        graph.addEdge(source, primitive, 0);
      }
      if (primitive.j === samples.length) {
        graph.addEdge(primitive, target, 0);
      }
    }
    for (_j = 0, _len1 = primitives.length; _j < _len1; _j++) {
      start = primitives[_j];
      for (_k = 0, _len2 = primitives.length; _k < _len2; _k++) {
        end = primitives[_k];
        if ((start.j - 2 <= (_ref = end.i) && _ref <= start.j - 1)) {
          graph.addEdge(start, end, transitionCost(start, end) + 2);
        }
      }
    }
    path = graph.findShortestPath(source, target);
    path = path.slice(1, path.length - 1);
    adjustedPath = [path[0]];
    for (i = _l = 0, _len3 = path.length; _l < _len3; i = ++_l) {
      current = path[i];
      if (!(i > 0)) {
        continue;
      }
      previous = adjustedPath[i - 1];
      if (previous instanceof Circle && current instanceof Circle) {
        distance = distanceBetweenPoints(previous.center, current.center);
        possibleRadiuses = [distance - previous.radius, distance + previous.radius, previous.radius - distance];
        radius = _.min(possibleRadiuses, function(r) {
          return Math.abs(r - current.radius);
        });
        adjusted = new Circle(current.center, radius);
      } else if (previous instanceof Circle && current instanceof Line) {
        v = n.sub(previous.center, current.start);
        parallelComponent = n.mul(n.dot(current.direction, v), current.direction);
        perpendicularComponent = n.sub(v, parallelComponent);
        perpendicularDirection = n.div(perpendicularComponent, n.norm2(perpendicularComponent));
        possibleStarts = [n.add(previous.center, n.mul(perpendicularDirection, previous.radius)), n.sub(previous.center, n.mul(perpendicularDirection, previous.radius))];
        start = _.min(possibleStarts, function(s) {
          return (new Line(s, current.direction)).distanceToPoint(current.start);
        });
        adjusted = new Line(start, current.direction);
      } else if (previous instanceof Line && current instanceof Circle) {
        distance = previous.distanceToPoint(current.center);
        adjusted = new Circle(current.center, distance);
      }
      adjustedPath.push(adjusted);
    }
    console.log("adjustedPath", adjustedPath);
    _results = [];
    for (_m = 0, _len4 = adjustedPath.length; _m < _len4; _m++) {
      primitive = adjustedPath[_m];
      _results.push(primitive.draw());
    }
    return _results;
  };

  angleBetweenPoints = function(p1, p2) {
    var dx, dy;
    dy = p2[1] - p1[1];
    dx = p2[0] - p1[0];
    return Math.atan2(dy, dx);
  };

  quadranceBetweenPoints = function(p1, p2) {
    var dx, dy;
    dx = p2[0] - p1[0];
    dy = p2[1] - p1[1];
    return dx * dx + dy * dy;
  };

  distanceBetweenPoints = function(p1, p2) {
    return Math.sqrt(quadranceBetweenPoints(p1, p2));
  };

  circleFitMaxError = function(samples, circle) {
    var distance, error, maxError, sample, _i, _len;
    maxError = 0;
    for (_i = 0, _len = samples.length; _i < _len; _i++) {
      sample = samples[_i];
      distance = distanceBetweenPoints(sample, circle.center);
      error = Math.abs(distance - circle.radius);
      maxError = Math.max(error, maxError);
    }
    return maxError;
  };

  (function() {
    n = numeric;
    n.mean = function(samples) {
      var sample, sum, _i, _len;
      sum = [0, 0];
      for (_i = 0, _len = samples.length; _i < _len; _i++) {
        sample = samples[_i];
        n.addeq(sum, sample);
      }
      return n.div(sum, samples.length);
    };
    n.eigenvectors = function(matrix) {
      var eig, solution, solutionT;
      eig = n.eig(matrix);
      solution = eig.E.x;
      solutionT = n.transpose(solution);
      return solutionT;
    };
    return n.eigen = function(matrix) {
      var eig, eigenvalues, eigenvector, eigenvectors, i, result, _i, _len;
      eig = n.eig(matrix);
      eigenvectors = n.transpose(eig.E.x);
      eigenvalues = eig.lambda.x;
      result = [];
      for (i = _i = 0, _len = eigenvectors.length; _i < _len; i = ++_i) {
        eigenvector = eigenvectors[i];
        result.push({
          eigenvector: eigenvector,
          eigenvalue: eigenvalues[i]
        });
      }
      result = _.sortBy(result, function(eigen) {
        return -eigen.eigenvalue;
      });
      return result;
    };
  })();

}).call(this);
