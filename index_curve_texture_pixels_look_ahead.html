<!--
  @TODO: Find all original inspiration code

  Empty Cursor website

  Color Palette
  http://www.colourlovers.com/palette/3412827/21st

  Bezier Tangent End Point
  Bezier mirrored control points
  ???
  http://pomax.github.io/bezierinfo/

  Bezier Equation from StackOverflow
  http://stackoverflow.com/questions/5634460/quadratic-bezier-curve-calculate-point

  Bezier Length
  http://books.google.com/books?id=8CGj9_ZlFKoC&lpg=PA199&ots=yB9xOx-sGF&dq=bezier%20control%20polygon%20length&pg=PA199#v=onepage&q=bezier%20control%20polygon%20length&f=false

  Alpha Compositing
  http://en.wikipedia.org/wiki/Alpha_compositing

  Line Scattering and General Techniques
  http://perfectionkills.com/exploring-canvas-drawing-techniques/#_=_

  Convolution/sharpness

  Convolution/contrast

  Wacom SDK?

-->

<html>
<head>
<style>
body {
  font-family: sans-serif;
}
canvas {
  float: left;
  cursor: url('cursors/cursor.cur'), crosshair;
  border: 1px solid gray;
}
img {
  display: none;
}
a {
  padding: 10px;
  line-height: 40px;
  cursor: pointer;
  color: white;
  text-decoration: none;
  -moz-user-select: none;
}
#save {
  background: #3B2D38;
}
#clear {
  background: #F02475;
}
</style>
</head>

<body>
<canvas id="canvas"></canvas>
<div id="buttons">
  <a id="save">Save</a>
  <br>
  <br>
  <br>
  <a id="clear">Clear</a>
</div>
<img src="img/circle_ballpoint_4.png" id="texture"/>
<object id="wtPlugin" type="application/x-wacomtabletplugin">
  <param name="onload" value="pluginLoaded"/>
</object>
</body>

<script>
// State
var w = 1300;
var h = 1000;
var ratio = 1;
var sample = 1;
var cursorOffsetX = 13;
var cursorOffsetY = 9;
var points = [];
var isDrawing = false;
var mouseMoveCounter = 0;

// DOM
var canvas;
var save;
var clear;
var texture;
var textureImageData;
var plugin;
var ctx;
var lastControlPoint;

window.onload = function() {
  initDOMElements();
  initEvents();
  clearCanvas();
}

function initDOMElements() {canvas = document.getElementById('canvas');
  canvas.setAttribute('width', w * ratio);
  canvas.setAttribute('height', h * ratio);
  canvas.style.width = w;
  canvas.style.height = h;
  save = document.getElementById('save');
  clear = document.getElementById('clear');
  texture = document.getElementById("texture");
  plugin = document.getElementById('wtPlugin');
  ctx = canvas.getContext('2d');
  ctx.scale(ratio, ratio);

  // texture image data
  var wt = texture.width;
  var ht = texture.height;
  var c = document.createElement('canvas');
  var x = c.getContext('2d');
  c.style.width = wt;
  c.style.height = ht;
  x.drawImage(texture, 0, 0);
  textureImageData = x.getImageData(0,0,wt,ht);
  textureImageData = textureImageData.data;
  //console.log(textureImageData);
}

function initEvents() {
  save.onclick = function(e) {
    window.open(canvas.toDataURL());
  }
  clear.onclick = function(e) {
    clearCanvas();
  }
  canvas.onmousedown = function(e) {
    isDrawing = true;    recordPoint(e);
    mouseMoveCounter++;
  };
  canvas.onmousemove = function(e) {
    var self = this;
    mouseMoveCounter++;
    if (!isDrawing) return;
    //if ((mouseMoveCounter % 4) !== 0) return;
    recordPoint(e);
    redraw();
  }
  canvas.onmouseup = function(e) {
    isDrawing = false;
    //recordPoint(e);
    points = [];
    lastControlPoint = null;
  };
}

function redraw() {
  if (!isDrawing) {
    return;
  }
  // 3 points needed for a look-ahead quadratic bezier
  if(points.length === 3) {
    var p1 = points[1];
    var p2 = points[2];
    drawCurve(points);
    points = [];
    points.push(p1);
    points.push(p2);
  }
};

// draws a quadratic bezier according to 3 input points
function drawCurve(pts) {
  var imageData = ctx.getImageData(0, 0, w * ratio, h * ratio);
  var p0 = from = pts[0];
  var p1 = to = pts[1];
  var p2 = pts[2];

  if(!lastControlPoint) {
    lastControlPoint = getMidPt(p0, p1);
  }
   
  // Evelyn's look ahead?                  
  var p01 = getMidPt(p0, p1);
  var p12 = getMidPt(p1, p2);
  var ctrl = getMidPt(
    getMidPt(getMirroredPt(lastControlPoint, p0), p01),
    getMidPt(getMirroredPt(getMidPt(getMirroredPt(p01, p1), p12), p1), p01)
  );
  var ctrl = getMidPt(
    getMidPt(getMirroredPt(lastControlPoint, p0), p01),
    getMidPt(getMirroredPt(getMidPt(getMirroredPt(p01, p1), p12), p1), p01)
  );
  /*var ctrl = {
    x: (13/16)*p0.x + (1/2)*p1.x - (1/4)*lastControlPoint.x - (1/16)*p2.x,
    y: (13/16)*p0.y + (1/2)*p1.y - (1/4)*lastControlPoint.y - (1/16)*p2.y
  }*/

  /*var ctrl = {
    x: (13/16)*p0.x + (8/16)*p1.x - (4/16)*lastControlPoint.x - (1/16)*p2.x,
    y: (13/16)*p0.y + (8/16)*p1.y - (4/16)*lastControlPoint.y - (1/16)*p2.y
  }*/

  lastControlPoint = ctrl;
  var p = (from.p + to.p)/2;

  // step along Bezier - Dan Amelang
  var D_x = 2 * (ctrl.x - from.x);
  var D_y = 2 * (ctrl.y - from.y);
  var E_x = 2 * (from.x - 2 * ctrl.x + to.x);
  var E_y = 2 * (from.y - 2 * ctrl.y + to.y);
  var t = 0.0;
  while (t <= 1.0) {
    var u = 1 - t;
    var B0 = u * u;
    var B1 = 2 * u * t;
    var B2 = t * t;
    var step_x = B0 * from.x + B1 * ctrl.x + B2 * to.x;
    var step_y = B0 * from.y + B1 * ctrl.y + B2 * to.y;
    var s_x = D_x + t * E_x;
    var s_y = D_y + t * E_y;
    var s = Math.sqrt(s_x * s_x + s_y * s_y);

    var factor;
    var dt;

    p = 0.95;

    if(p < 0.2) {

      dt = 1 / (1.23*s);

    }
    if((p >= 0.2) && (p < 0.3)) {

      dt = 1 / (1.25*s);

    }
    if((p >= 0.3) && (p < 0.4)) {

      dt = 1 / (1.27*s);

    }
    if((p >= 0.4) && (p < 0.5)) {

      dt = 1 / (1.29*s);

    }
    if((p >= 0.5) && (p < 0.95)) {

      dt = 1 / (1.31*s);

    }
    if(p >= 0.95) {

      dt = 1 / (1.33*s);

    }
    t = t + dt;

    // draw 3x3 "pixel"
    drawPixel(imageData, step_x, step_y, p);

  }
  ctx.putImageData(imageData, 0, 0);
}

function drawPixel(id, x, y, p) {
  for(var i = -1; i < 2; i++) {
    for(var j = -1; j < 2; j++) {

      var idx = ((Math.round(x) + i) + (Math.round(y) + j)*w*ratio)*4;
      var dist = getDistance({x: x, y: y}, {x: Math.round(x) + i, y: Math.round(y) + j});

      var factor;
      var a;
      if(p < 0.2) {

        a = -0.33/(dist-0.02)+1.22;

      }
      if((p >= 0.2) && (p < 0.3)) {

        a = -0.33/(dist-0.04)+1.20;

      }
      if((p >= 0.3) && (p < 0.4)) {

        a = -0.33/(dist-0.06)+1.18;

      }
      if((p >= 0.4) && (p < 0.5)) {

        a = -0.33/(dist-0.08)+1.16;

      }
      if((p >= 0.5) && (p < 0.95)) {

        a = -0.33/(dist-0.10)+1.14;

      }
      if(p >= 0.95) {

        a = -0.2/(dist-0.12)+1.12;

      }
      //factor *= p;

      //var a = (-0.42-factor)/(dist)+(1.28-factor);
      //var a = (-0.42)/(dist)+(1.28);

      /////////////////////////////
      // a = 0 = opaque
      // a = 1 = transparent
      /////////////////////////////
      if (a < 0) a = 0;
      if (a > 1) a = 1;

      id.data[idx + 0] = id.data[idx + 0] * a + 0 * a * (1 - a);
      id.data[idx + 1] = id.data[idx + 1] * a + 0 * a * (1 - a);
      id.data[idx + 2] = id.data[idx + 2] * a + 50 * a * (1 - a);
      id.data[idx + 3] = 255;
    }
  }
}

function recordPoint(e) {
  point = {
    x   : e.clientX - cursorOffsetX,
    y   : e.clientY - cursorOffsetY,
    p   : plugin.penAPI.pressure
  };
  points.push(point);
}

function clearCanvas(){
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = 'rgb(253, 254, 251)';
  ctx.globalAlpha = 1;
  ctx.fillRect(0, 0, w, h);
}

// UTILS

function getMidPt(p1, p2) {
  return {
    x: (p1.x + p2.x) / 2,
    y: (p1.y + p2.y) / 2
  };
}

function getMirroredPt(p1, p2) {
  // mirror A through B (2Bx−Ax, 2By−Ay)
  return {
    x: 2*p2.x - p1.x,
    y: 2*p2.y - p1.y
  }
}

function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

</script>
</html>