<html>
  <head>

    <!-- CSS -->
    <style>
      canvas {
        cursor: url('cursor.cur'), crosshair; /* created at cursor.cc */
        border-top-right-radius: 25px;
        border-bottom-right-radius: 25px;
        border-top: 1px solid #DDC;
        border-bottom: 1px solid #DDC;
        border-right: 1px solid #DDC;
        margin-left: -4px;
      }
      img {
        border-left: 1px solid #DDC;
        border-top: 1px solid #DDC;
        border-bottom: 1px solid #DDC;
        border-top-left-radius: 25px;
        border-bottom-left-radius: 25px;
      }
      object {
        width: 0;
        height: 0;
      }
      div#book {
        background-color: #553456;
        border-radius: 5px;
        width: calc(787px * 2);
        height: 1003px;
        margin-left: auto;
        margin-right: auto;
      }
    </style>

  </head>

  <!-- HTML ELEMENTS -->
  <body>

    <!-- NOTEBOOK -->
    <div id="book">
      <img src="notebook.png">
      <canvas id="c" width="786px" height="1001px"></canvas>
    </div>

    <!-- WACOM PLUGIN -->
    <object id="wtPlugin" type="application/x-wacomtabletplugin">
      <param name="onload" value="pluginLoaded" />
    </object>

  </body>

  <!-- JS -->
  <script>

    //***********************
    // Wacom Plugin
    //
    function getWacomPlugin() {
      var plugin = document.getElementById('wtPlugin');
      return plugin;
    }

    //***********************
    // Max Window
    // http://stackoverflow.com/questions/1125084/how-to-make-in-javascript-full-screen-windows-stretching-all-over-the-screen

    window.onload = maxWindow;

    function maxWindow() {
        window.moveTo(0, 0);


        if (document.all) {
            top.window.resizeTo(screen.availWidth, screen.availHeight);
        }

        else if (document.layers || document.getElementById) {
            if (top.window.outerHeight < screen.availHeight || top.window.outerWidth < screen.availWidth) {
                top.window.outerHeight = screen.availHeight;
                top.window.outerWidth = screen.availWidth;
            }
        }
    }

    //***********************
    // Helpers

    function cursorOffset(e, el) {
      var pt = {};
      pt.x = e.pageX - el.offsetLeft + 0;
      pt.y = e.pageY - el.offsetTop + 0;
      return pt;
    }

    function mapWidth(v) {
      var result = 3*v;
      return result;
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      ctx.fillStyle = paperColor;
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    }

    //***********************
    // Keyboard presses

    window.onkeypress = function(e) {
      // 'c' clears canvas
      if (e.charCode === 99) {
        clearCanvas();
      }

      // 'i' saves canvas image
      if (e.charCode === 105) {
        window.open(el.toDataURL());
      }
    }

    
    //***********************
    // Canvas Drawing: Separate Paths

    var el = document.getElementById('c');
    var ctx = el.getContext('2d');
    var isDrawing;
    var oldX;
    var oldY;
    var paperColor = "rgb(253, 253, 240);";
    var penColor = "rgb(20, 5, 0);";
    var shadowColor = "rgba(255, 225, 100, 0.5);";

    //ctx.lineCap = "round";
    //ctx.lineJoin = "round";
    //ctx.shadowBlur = 5;
    //ctx.shadowColor = shadowColor;
    ctx.strokeStyle = penColor;
    clearCanvas();

    // Set isDrawing to true
    // Record the mouse position
    el.onmousedown = function(e) {
      isDrawing = true;
      oldX = cursorOffset(e, el).x;
      oldY = cursorOffset(e, el).y;
    };

    // Start a path
    // Move to old mouse position
    // Draw line to new mouse position
    // Close the path and stroke
    // Reset the old mouse position to new mouse position
    el.onmousemove = function(e) {
      if (isDrawing) {
        var pressure = getWacomPlugin().penAPI.pressure;
        ctx.beginPath(); // begins the current path
        ctx.moveTo(oldX, oldY);
        ctx.lineTo(
          cursorOffset(e, el).x,
          cursorOffset(e, el).y
        );
        ctx.setLineWidth(mapWidth(pressure));
        ctx.stroke();
        ctx.closePath(); // closes the current path
        oldX = cursorOffset(e, el).x;
        oldY = cursorOffset(e, el).y;
      }
    };

    // Set isDrawing to false
    el.onmouseup = function() {
      isDrawing = false;
    };

    /*//***********************
    // Canvas Drawing: Bezier Curves

    function midPointBtw(p1, p2) {
      return {
        x: p1.x + (p2.x - p1.x) / 2,
        y: p1.y + (p2.y - p1.y) / 2
      };
    }

    var el = document.getElementById('c');
    var ctx = el.getContext('2d');

    //ctx.lineWidth = 10;
    ctx.lineJoin = ctx.lineCap = 'round';

    var isDrawing, points = [ ];
    var paperColor = "rgb(253, 253, 240);";
    var penColor = "rgb(20, 5, 0);";
    var shadowColor = "rgba(255, 225, 100, 0.5);";
    ctx.shadowBlur = 1;
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    clearCanvas();

    el.onmousedown = function(e) {
      isDrawing = true;
      points.push({
        x: cursorOffset(e, el).x,
        y: cursorOffset(e, el).y,
        p: getWacomPlugin().penAPI.pressure
      });
    };

    el.onmousemove = function(e) {
      if (!isDrawing) return;
      
      points.push({
        x: cursorOffset(e, el).x,
        y: cursorOffset(e, el).y,
        p: getWacomPlugin().penAPI.pressure
      });

      //ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      //clearCanvas();
      
      var p1 = points[0];
      var p2 = points[1];
      
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      //console.log(points);

      for (var i = 1, len = points.length; i < len; i++) {
        // we pick the point between pi+1 & pi+2 as the
        // end point and p1 as our control point
        //if(i > 1) {
        //  ctx.beginPath();
        //}
        var midPoint = midPointBtw(p1, p2);
        ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
        //ctx.setLineWidth(mapWidth(p1.p)); // pressure
        //ctx.stroke();
        //ctx.closePath();
        p1 = points[i];
        p2 = points[i+1];
      }
      // Draw last line as a straight line while
      // we wait for the next point to be able to calculate
      // the bezier control point
      //ctx.beginPath();
      ctx.lineTo(p1.x, p1.y);
      ctx.setLineWidth(mapWidth(p1.p)); // pressure
      ctx.stroke();
      //ctx.closePath();
    };

    el.onmouseup = function() {
      isDrawing = false;
      points.length = 0;
    };*/
  </script>

</html>